/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "MocktvSettings.h"

static const char* CMockString_ConvertHDRFormatToContentFormat = "ConvertHDRFormatToContentFormat";
static const char* CMockString_ConvertTVColorToVendorColor = "ConvertTVColorToVendorColor";
static const char* CMockString_ConvertVideoFormatToHDRFormat = "ConvertVideoFormatToHDRFormat";
static const char* CMockString_GetAllSupportedPicModeIndex = "GetAllSupportedPicModeIndex";
static const char* CMockString_GetAspectRatio = "GetAspectRatio";
static const char* CMockString_GetBacklight = "GetBacklight";
static const char* CMockString_GetBrightness = "GetBrightness";
static const char* CMockString_GetCMSDefault = "GetCMSDefault";
static const char* CMockString_GetColorTemp_B_post_offset = "GetColorTemp_B_post_offset";
static const char* CMockString_GetColorTemp_B_post_offset_onSource = "GetColorTemp_B_post_offset_onSource";
static const char* CMockString_GetColorTemp_Bgain = "GetColorTemp_Bgain";
static const char* CMockString_GetColorTemp_Bgain_onSource = "GetColorTemp_Bgain_onSource";
static const char* CMockString_GetColorTemp_G_post_offset = "GetColorTemp_G_post_offset";
static const char* CMockString_GetColorTemp_G_post_offset_onSource = "GetColorTemp_G_post_offset_onSource";
static const char* CMockString_GetColorTemp_Ggain = "GetColorTemp_Ggain";
static const char* CMockString_GetColorTemp_Ggain_onSource = "GetColorTemp_Ggain_onSource";
static const char* CMockString_GetColorTemp_R_post_offset = "GetColorTemp_R_post_offset";
static const char* CMockString_GetColorTemp_R_post_offset_onSource = "GetColorTemp_R_post_offset_onSource";
static const char* CMockString_GetColorTemp_Rgain = "GetColorTemp_Rgain";
static const char* CMockString_GetColorTemp_Rgain_onSource = "GetColorTemp_Rgain_onSource";
static const char* CMockString_GetColorTemperature = "GetColorTemperature";
static const char* CMockString_GetContrast = "GetContrast";
static const char* CMockString_GetCurrentBacklightMode = "GetCurrentBacklightMode";
static const char* CMockString_GetCurrentComponentHue = "GetCurrentComponentHue";
static const char* CMockString_GetCurrentComponentLuma = "GetCurrentComponentLuma";
static const char* CMockString_GetCurrentComponentSaturation = "GetCurrentComponentSaturation";
static const char* CMockString_GetCurrentContentFormat = "GetCurrentContentFormat";
static const char* CMockString_GetCurrentPQIndex = "GetCurrentPQIndex";
static const char* CMockString_GetCurrentVideoFormat = "GetCurrentVideoFormat";
static const char* CMockString_GetCustomPQModeIndex = "GetCustomPQModeIndex";
static const char* CMockString_GetDefaultPanelID = "GetDefaultPanelID";
static const char* CMockString_GetDolbyModeIndex = "GetDolbyModeIndex";
static const char* CMockString_GetDriverEquivalentBLForCurrentFmt = "GetDriverEquivalentBLForCurrentFmt";
static const char* CMockString_GetDynamicContrast = "GetDynamicContrast";
static const char* CMockString_GetGrayPattern = "GetGrayPattern";
static const char* CMockString_GetHDR10ModeIndex = "GetHDR10ModeIndex";
static const char* CMockString_GetHLGModeIndex = "GetHLGModeIndex";
static const char* CMockString_GetHue = "GetHue";
static const char* CMockString_GetLDIMAndEDIDLevel = "GetLDIMAndEDIDLevel";
static const char* CMockString_GetLocalDimmingLevel = "GetLocalDimmingLevel";
static const char* CMockString_GetNumberOfModesupported = "GetNumberOfModesupported";
static const char* CMockString_GetPanelID = "GetPanelID";
static const char* CMockString_GetRGBPattern = "GetRGBPattern";
static const char* CMockString_GetSaturation = "GetSaturation";
static const char* CMockString_GetSharpness = "GetSharpness";
static const char* CMockString_GetSupportedBacklightModes = "GetSupportedBacklightModes";
static const char* CMockString_GetSupportedComponentColor = "GetSupportedComponentColor";
static const char* CMockString_GetSupportedContentFormats = "GetSupportedContentFormats";
static const char* CMockString_GetTVBacklightGlobalFactor = "GetTVBacklightGlobalFactor";
static const char* CMockString_GetTVDolbyVisionMode = "GetTVDolbyVisionMode";
static const char* CMockString_GetTVHDR10Mode = "GetTVHDR10Mode";
static const char* CMockString_GetTVHLGMode = "GetTVHLGMode";
static const char* CMockString_GetTVPictureMode = "GetTVPictureMode";
static const char* CMockString_GetTVPictureModeIndex = "GetTVPictureModeIndex";
static const char* CMockString_GetTVSupportedDVModes = "GetTVSupportedDVModes";
static const char* CMockString_GetTVSupportedDimmingModes = "GetTVSupportedDimmingModes";
static const char* CMockString_GetTVSupportedHDR10Modes = "GetTVSupportedHDR10Modes";
static const char* CMockString_GetTVSupportedHLGModes = "GetTVSupportedHLGModes";
static const char* CMockString_GetTVSupportedPictureModes = "GetTVSupportedPictureModes";
static const char* CMockString_GetTint = "GetTint";
static const char* CMockString_GetUSerWBValueOnInit = "GetUSerWBValueOnInit";
static const char* CMockString_GetVideoFrameRate = "GetVideoFrameRate";
static const char* CMockString_GetVideoResolution = "GetVideoResolution";
static const char* CMockString_GetWBRgbType = "GetWBRgbType";
static const char* CMockString_Luma = "Luma";
static const char* CMockString_ReadAllModeConfigfile = "ReadAllModeConfigfile";
static const char* CMockString_ResetBacklight = "ResetBacklight";
static const char* CMockString_ResetBrightness = "ResetBrightness";
static const char* CMockString_ResetColorTemperature = "ResetColorTemperature";
static const char* CMockString_ResetComponentHue = "ResetComponentHue";
static const char* CMockString_ResetComponentLuma = "ResetComponentLuma";
static const char* CMockString_ResetComponentSaturation = "ResetComponentSaturation";
static const char* CMockString_ResetContrast = "ResetContrast";
static const char* CMockString_ResetHue = "ResetHue";
static const char* CMockString_ResetSaturation = "ResetSaturation";
static const char* CMockString_ResetSharpness = "ResetSharpness";
static const char* CMockString_SaveBacklight = "SaveBacklight";
static const char* CMockString_SaveBrightness = "SaveBrightness";
static const char* CMockString_SaveCMS = "SaveCMS";
static const char* CMockString_SaveColorTemperature = "SaveColorTemperature";
static const char* CMockString_SaveColorTemperatureUser = "SaveColorTemperatureUser";
static const char* CMockString_SaveContrast = "SaveContrast";
static const char* CMockString_SaveDisplayMode = "SaveDisplayMode";
static const char* CMockString_SaveDolbyMode = "SaveDolbyMode";
static const char* CMockString_SaveDynamicBacklight = "SaveDynamicBacklight";
static const char* CMockString_SaveHue = "SaveHue";
static const char* CMockString_SaveLocalDimmingLevel = "SaveLocalDimmingLevel";
static const char* CMockString_SaveSaturation = "SaveSaturation";
static const char* CMockString_SaveSharpness = "SaveSharpness";
static const char* CMockString_SetAspectRatio = "SetAspectRatio";
static const char* CMockString_SetBacklight = "SetBacklight";
static const char* CMockString_SetBacklightFade = "SetBacklightFade";
static const char* CMockString_SetBacklightInfo = "SetBacklightInfo";
static const char* CMockString_SetBrightness = "SetBrightness";
static const char* CMockString_SetCMSState = "SetCMSState";
static const char* CMockString_SetColorTemp_B_post_offset = "SetColorTemp_B_post_offset";
static const char* CMockString_SetColorTemp_B_post_offset_onSource = "SetColorTemp_B_post_offset_onSource";
static const char* CMockString_SetColorTemp_Bgain = "SetColorTemp_Bgain";
static const char* CMockString_SetColorTemp_Bgain_onSource = "SetColorTemp_Bgain_onSource";
static const char* CMockString_SetColorTemp_G_post_offset = "SetColorTemp_G_post_offset";
static const char* CMockString_SetColorTemp_G_post_offset_onSource = "SetColorTemp_G_post_offset_onSource";
static const char* CMockString_SetColorTemp_Ggain = "SetColorTemp_Ggain";
static const char* CMockString_SetColorTemp_Ggain_onSource = "SetColorTemp_Ggain_onSource";
static const char* CMockString_SetColorTemp_R_post_offset = "SetColorTemp_R_post_offset";
static const char* CMockString_SetColorTemp_R_post_offset_onSource = "SetColorTemp_R_post_offset_onSource";
static const char* CMockString_SetColorTemp_Rgain = "SetColorTemp_Rgain";
static const char* CMockString_SetColorTemp_Rgain_onSource = "SetColorTemp_Rgain_onSource";
static const char* CMockString_SetColorTemperature = "SetColorTemperature";
static const char* CMockString_SetColorTemperatureUser = "SetColorTemperatureUser";
static const char* CMockString_SetContrast = "SetContrast";
static const char* CMockString_SetCurrentBacklightMode = "SetCurrentBacklightMode";
static const char* CMockString_SetCurrentComponentHue = "SetCurrentComponentHue";
static const char* CMockString_SetCurrentComponentLuma = "SetCurrentComponentLuma";
static const char* CMockString_SetCurrentComponentSaturation = "SetCurrentComponentSaturation";
static const char* CMockString_SetDynamicContrast = "SetDynamicContrast";
static const char* CMockString_SetGammaMode = "SetGammaMode";
static const char* CMockString_SetGrayPattern = "SetGrayPattern";
static const char* CMockString_SetHue = "SetHue";
static const char* CMockString_SetLocalDimmingLevel = "SetLocalDimmingLevel";
static const char* CMockString_SetRGBPattern = "SetRGBPattern";
static const char* CMockString_SetSaturation = "SetSaturation";
static const char* CMockString_SetSharpness = "SetSharpness";
static const char* CMockString_SetTVBacklightGlobalFactor = "SetTVBacklightGlobalFactor";
static const char* CMockString_SetTVDimmingMode = "SetTVDimmingMode";
static const char* CMockString_SetTVDolbyVisionMode = "SetTVDolbyVisionMode";
static const char* CMockString_SetTVHDR10Mode = "SetTVHDR10Mode";
static const char* CMockString_SetTVHLGMode = "SetTVHLGMode";
static const char* CMockString_SetTVPictureMode = "SetTVPictureMode";
static const char* CMockString_SetTint = "SetTint";
static const char* CMockString_SwitchEDID = "SwitchEDID";
static const char* CMockString_UpdateEDIDAndSetDimmingLevel = "UpdateEDIDAndSetDimmingLevel";
static const char* CMockString_YUVValue = "YUVValue";
static const char* CMockString_areEqual = "areEqual";
static const char* CMockString_availableModes = "availableModes";
static const char* CMockString_b = "b";
static const char* CMockString_backlight = "backlight";
static const char* CMockString_backlightDefaults = "backlightDefaults";
static const char* CMockString_bgain = "bgain";
static const char* CMockString_blComponentColor = "blComponentColor";
static const char* CMockString_blHueColor = "blHueColor";
static const char* CMockString_blLumaColor = "blLumaColor";
static const char* CMockString_blMode = "blMode";
static const char* CMockString_blModes = "blModes";
static const char* CMockString_blSaturationColor = "blSaturationColor";
static const char* CMockString_bpostoffset = "bpostoffset";
static const char* CMockString_brightness = "brightness";
static const char* CMockString_buffer = "buffer";
static const char* CMockString_color = "color";
static const char* CMockString_colorTemp = "colorTemp";
static const char* CMockString_colorType = "colorType";
static const char* CMockString_color_tunel_type = "color_tunel_type";
static const char* CMockString_color_type = "color_type";
static const char* CMockString_colortemp = "colortemp";
static const char* CMockString_componentState = "componentState";
static const char* CMockString_contentFormats = "contentFormats";
static const char* CMockString_contrast = "contrast";
static const char* CMockString_count = "count";
static const char* CMockString_cpybuffer = "cpybuffer";
static const char* CMockString_ctrl = "ctrl";
static const char* CMockString_defaultValue = "defaultValue";
static const char* CMockString_dimmingLevel = "dimmingLevel";
static const char* CMockString_dimmingMode = "dimmingMode";
static const char* CMockString_dimmingModes = "dimmingModes";
static const char* CMockString_dispMode = "dispMode";
static const char* CMockString_dolbyMode = "dolbyMode";
static const char* CMockString_duration = "duration";
static const char* CMockString_dvModes = "dvModes";
static const char* CMockString_dynamicContrastEnable = "dynamicContrastEnable";
static const char* CMockString_edidLevel = "edidLevel";
static const char* CMockString_enableWBmode = "enableWBmode";
static const char* CMockString_file = "file";
static const char* CMockString_format = "format";
static const char* CMockString_from = "from";
static const char* CMockString_g = "g";
static const char* CMockString_getWBctrl = "getWBctrl";
static const char* CMockString_ggain = "ggain";
static const char* CMockString_gpostoffset = "gpostoffset";
static const char* CMockString_hdr10Mode = "hdr10Mode";
static const char* CMockString_hdrFormat = "hdrFormat";
static const char* CMockString_hdr_type = "hdr_type";
static const char* CMockString_hlgMode = "hlgMode";
static const char* CMockString_hue = "hue";
static const char* CMockString_inputSrc = "inputSrc";
static const char* CMockString_isCurrentHDRTypeIsSDR = "isCurrentHDRTypeIsSDR";
static const char* CMockString_isDynamicContrastEnabled = "isDynamicContrastEnabled";
static const char* CMockString_isWBUserDfault = "isWBUserDfault";
static const char* CMockString_localDimmingLevel = "localDimmingLevel";
static const char* CMockString_mode = "mode";
static const char* CMockString_numberOfFormats = "numberOfFormats";
static const char* CMockString_panelID = "panelID";
static const char* CMockString_panelid = "panelid";
static const char* CMockString_pic_mode_index = "pic_mode_index";
static const char* CMockString_pictureMode = "pictureMode";
static const char* CMockString_pictureModes = "pictureModes";
static const char* CMockString_pq_mode = "pq_mode";
static const char* CMockString_pqmode = "pqmode";
static const char* CMockString_r = "r";
static const char* CMockString_rangeMidPointValue = "rangeMidPointValue";
static const char* CMockString_res = "res";
static const char* CMockString_resetForAllFormats = "resetForAllFormats";
static const char* CMockString_rgain = "rgain";
static const char* CMockString_rgbType = "rgbType";
static const char* CMockString_rpostoffset = "rpostoffset";
static const char* CMockString_saturation = "saturation";
static const char* CMockString_saveOnly = "saveOnly";
static const char* CMockString_searchstring = "searchstring";
static const char* CMockString_setWBctrl = "setWBctrl";
static const char* CMockString_setWakeupConfig = "setWakeupConfig";
static const char* CMockString_sharpness = "sharpness";
static const char* CMockString_sourceId = "sourceId";
static const char* CMockString_sourceInput = "sourceInput";
static const char* CMockString_splitstringsandvaluefrombuffer = "splitstringsandvaluefrombuffer";
static const char* CMockString_splitstringsfrombuffer = "splitstringsfrombuffer";
static const char* CMockString_src_type = "src_type";
static const char* CMockString_tint = "tint";
static const char* CMockString_to = "to";
static const char* CMockString_totalcount = "totalcount";
static const char* CMockString_tunelType = "tunelType";
static const char* CMockString_tunnel_type = "tunnel_type";
static const char* CMockString_tvInit = "tvInit";
static const char* CMockString_tvSD3toCriSyncInit = "tvSD3toCriSyncInit";
static const char* CMockString_tvTerm = "tvTerm";
static const char* CMockString_value = "value";
static const char* CMockString_videoFormat = "videoFormat";
static const char* CMockString_wbvalue = "wbvalue";
static const char* CMockString_wbvalueThat = "wbvalueThat";
static const char* CMockString_wbvalueThis = "wbvalueThis";

typedef struct _CMOCK_tvInit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;

} CMOCK_tvInit_CALL_INSTANCE;

typedef struct _CMOCK_tvSD3toCriSyncInit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;

} CMOCK_tvSD3toCriSyncInit_CALL_INSTANCE;

typedef struct _CMOCK_tvTerm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;

} CMOCK_tvTerm_CALL_INSTANCE;

typedef struct _CMOCK_GetTVPictureMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  char* Expected_pictureMode;

} CMOCK_GetTVPictureMode_CALL_INSTANCE;

typedef struct _CMOCK_SetTVPictureMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  const char* Expected_pictureMode;

} CMOCK_SetTVPictureMode_CALL_INSTANCE;

typedef struct _CMOCK_GetBacklight_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_backlight;

} CMOCK_GetBacklight_CALL_INSTANCE;

typedef struct _CMOCK_SetBacklight_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_backlight;

} CMOCK_SetBacklight_CALL_INSTANCE;

typedef struct _CMOCK_SetBrightness_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_brightness;

} CMOCK_SetBrightness_CALL_INSTANCE;

typedef struct _CMOCK_GetBrightness_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_brightness;

} CMOCK_GetBrightness_CALL_INSTANCE;

typedef struct _CMOCK_SetContrast_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_contrast;

} CMOCK_SetContrast_CALL_INSTANCE;

typedef struct _CMOCK_GetContrast_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_contrast;

} CMOCK_GetContrast_CALL_INSTANCE;

typedef struct _CMOCK_SetSharpness_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sharpness;

} CMOCK_SetSharpness_CALL_INSTANCE;

typedef struct _CMOCK_GetSharpness_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_sharpness;

} CMOCK_GetSharpness_CALL_INSTANCE;

typedef struct _CMOCK_SetSaturation_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_saturation;

} CMOCK_SetSaturation_CALL_INSTANCE;

typedef struct _CMOCK_GetSaturation_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_saturation;

} CMOCK_GetSaturation_CALL_INSTANCE;

typedef struct _CMOCK_SetHue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_hue;

} CMOCK_SetHue_CALL_INSTANCE;

typedef struct _CMOCK_GetHue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_hue;

} CMOCK_GetHue_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemperature_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;

} CMOCK_SetColorTemperature_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemperature_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t* Expected_colorTemp;

} CMOCK_GetColorTemperature_CALL_INSTANCE;

typedef struct _CMOCK_SetAspectRatio_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvDisplayMode_t Expected_dispMode;

} CMOCK_SetAspectRatio_CALL_INSTANCE;

typedef struct _CMOCK_GetAspectRatio_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvDisplayMode_t* Expected_dispMode;

} CMOCK_GetAspectRatio_CALL_INSTANCE;

typedef struct _CMOCK_GetTint_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_tint;

} CMOCK_GetTint_CALL_INSTANCE;

typedef struct _CMOCK_SetTint_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_tint;

} CMOCK_SetTint_CALL_INSTANCE;

typedef struct _CMOCK_GetSupportedBacklightModes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_blModes;

} CMOCK_GetSupportedBacklightModes_CALL_INSTANCE;

typedef struct _CMOCK_GetCurrentBacklightMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvBacklightMode_t* Expected_blMode;

} CMOCK_GetCurrentBacklightMode_CALL_INSTANCE;

typedef struct _CMOCK_SetCurrentBacklightMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvBacklightMode_t Expected_blMode;

} CMOCK_SetCurrentBacklightMode_CALL_INSTANCE;

typedef struct _CMOCK_GetCurrentVideoFormat_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvVideoHDRFormat_t* Expected_format;

} CMOCK_GetCurrentVideoFormat_CALL_INSTANCE;

typedef struct _CMOCK_GetVideoResolution_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvResolutionParam_t* Expected_res;

} CMOCK_GetVideoResolution_CALL_INSTANCE;

typedef struct _CMOCK_GetVideoFrameRate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvVideoFrameRate_t* Expected_format;

} CMOCK_GetVideoFrameRate_CALL_INSTANCE;

typedef struct _CMOCK_setWakeupConfig_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvWakeupSrcType_t Expected_src_type;
  bool Expected_value;

} CMOCK_setWakeupConfig_CALL_INSTANCE;

typedef struct _CMOCK_SetRGBPattern_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_r;
  int Expected_g;
  int Expected_b;

} CMOCK_SetRGBPattern_CALL_INSTANCE;

typedef struct _CMOCK_GetRGBPattern_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_r;
  int* Expected_g;
  int* Expected_b;

} CMOCK_GetRGBPattern_CALL_INSTANCE;

typedef struct _CMOCK_SetGrayPattern_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_YUVValue;

} CMOCK_SetGrayPattern_CALL_INSTANCE;

typedef struct _CMOCK_GetGrayPattern_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_YUVValue;

} CMOCK_GetGrayPattern_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemp_Rgain_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int Expected_rgain;

} CMOCK_SetColorTemp_Rgain_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemp_Rgain_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int* Expected_rgain;

} CMOCK_GetColorTemp_Rgain_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemp_Ggain_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int Expected_ggain;

} CMOCK_SetColorTemp_Ggain_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemp_Ggain_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int* Expected_ggain;

} CMOCK_GetColorTemp_Ggain_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemp_Bgain_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int Expected_bgain;

} CMOCK_SetColorTemp_Bgain_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemp_Bgain_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int* Expected_bgain;

} CMOCK_GetColorTemp_Bgain_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemp_R_post_offset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int Expected_rpostoffset;

} CMOCK_SetColorTemp_R_post_offset_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemp_R_post_offset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int* Expected_rpostoffset;

} CMOCK_GetColorTemp_R_post_offset_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemp_G_post_offset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int Expected_gpostoffset;

} CMOCK_SetColorTemp_G_post_offset_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemp_G_post_offset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int* Expected_gpostoffset;

} CMOCK_GetColorTemp_G_post_offset_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemp_B_post_offset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int Expected_bpostoffset;

} CMOCK_SetColorTemp_B_post_offset_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemp_B_post_offset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int* Expected_bpostoffset;

} CMOCK_GetColorTemp_B_post_offset_CALL_INSTANCE;

typedef struct _CMOCK_GetTVSupportedPictureModes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  pic_modes_t** Expected_pictureModes;
  unsigned short* Expected_count;

} CMOCK_GetTVSupportedPictureModes_CALL_INSTANCE;

typedef struct _CMOCK_GetTVSupportedDVModes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  pic_modes_t** Expected_dvModes;
  unsigned short* Expected_count;

} CMOCK_GetTVSupportedDVModes_CALL_INSTANCE;

typedef struct _CMOCK_SetTVDolbyVisionMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  const char* Expected_dolbyMode;

} CMOCK_SetTVDolbyVisionMode_CALL_INSTANCE;

typedef struct _CMOCK_GetTVDolbyVisionMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  char* Expected_dolbyMode;

} CMOCK_GetTVDolbyVisionMode_CALL_INSTANCE;

typedef struct _CMOCK_SetTVHLGMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  const char* Expected_hlgMode;

} CMOCK_SetTVHLGMode_CALL_INSTANCE;

typedef struct _CMOCK_SetTVHDR10Mode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  const char* Expected_hdr10Mode;

} CMOCK_SetTVHDR10Mode_CALL_INSTANCE;

typedef struct _CMOCK_GetTVHLGMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  char* Expected_hlgMode;

} CMOCK_GetTVHLGMode_CALL_INSTANCE;

typedef struct _CMOCK_GetTVHDR10Mode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  char* Expected_hdr10Mode;

} CMOCK_GetTVHDR10Mode_CALL_INSTANCE;

typedef struct _CMOCK_GetTVSupportedHLGModes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  pic_modes_t** Expected_dvModes;
  unsigned short* Expected_count;

} CMOCK_GetTVSupportedHLGModes_CALL_INSTANCE;

typedef struct _CMOCK_GetTVSupportedHDR10Modes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  pic_modes_t** Expected_dvModes;
  unsigned short* Expected_count;

} CMOCK_GetTVSupportedHDR10Modes_CALL_INSTANCE;

typedef struct _CMOCK_SetDynamicContrast_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  const char* Expected_dynamicContrastEnable;

} CMOCK_SetDynamicContrast_CALL_INSTANCE;

typedef struct _CMOCK_GetDynamicContrast_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  char* Expected_isDynamicContrastEnabled;

} CMOCK_GetDynamicContrast_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemp_Rgain_onSource_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int Expected_rgain;
  int Expected_sourceId;
  int Expected_saveOnly;

} CMOCK_SetColorTemp_Rgain_onSource_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemp_Rgain_onSource_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int* Expected_rgain;
  int Expected_sourceId;

} CMOCK_GetColorTemp_Rgain_onSource_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemp_Ggain_onSource_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int Expected_ggain;
  int Expected_sourceId;
  int Expected_saveOnly;

} CMOCK_SetColorTemp_Ggain_onSource_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemp_Ggain_onSource_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int* Expected_ggain;
  int Expected_sourceId;

} CMOCK_GetColorTemp_Ggain_onSource_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemp_Bgain_onSource_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int Expected_bgain;
  int Expected_sourceId;
  int Expected_saveOnly;

} CMOCK_SetColorTemp_Bgain_onSource_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemp_Bgain_onSource_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int* Expected_bgain;
  int Expected_sourceId;

} CMOCK_GetColorTemp_Bgain_onSource_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemp_R_post_offset_onSource_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int Expected_rpostoffset;
  int Expected_sourceId;
  int Expected_saveOnly;

} CMOCK_SetColorTemp_R_post_offset_onSource_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemp_R_post_offset_onSource_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int* Expected_rpostoffset;
  int Expected_sourceId;

} CMOCK_GetColorTemp_R_post_offset_onSource_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemp_G_post_offset_onSource_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int Expected_gpostoffset;
  int Expected_sourceId;
  int Expected_saveOnly;

} CMOCK_SetColorTemp_G_post_offset_onSource_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemp_G_post_offset_onSource_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int* Expected_gpostoffset;
  int Expected_sourceId;

} CMOCK_GetColorTemp_G_post_offset_onSource_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemp_B_post_offset_onSource_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int Expected_bpostoffset;
  int Expected_sourceId;
  int Expected_saveOnly;

} CMOCK_SetColorTemp_B_post_offset_onSource_CALL_INSTANCE;

typedef struct _CMOCK_GetColorTemp_B_post_offset_onSource_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvColorTemp_t Expected_colorTemp;
  int* Expected_bpostoffset;
  int Expected_sourceId;

} CMOCK_GetColorTemp_B_post_offset_onSource_CALL_INSTANCE;

typedef struct _CMOCK_setWBctrl_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  char* Expected_inputSrc;
  char* Expected_colorTemp;
  char* Expected_color;
  char* Expected_ctrl;
  int Expected_value;

} CMOCK_setWBctrl_CALL_INSTANCE;

typedef struct _CMOCK_getWBctrl_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  char* Expected_inputSrc;
  char* Expected_colortemp;
  char* Expected_color;
  char* Expected_ctrl;
  int* Expected_value;

} CMOCK_getWBctrl_CALL_INSTANCE;

typedef struct _CMOCK_enableWBmode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  bool Expected_value;

} CMOCK_enableWBmode_CALL_INSTANCE;

typedef struct _CMOCK_GetSupportedComponentColor_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_blComponentColor;

} CMOCK_GetSupportedComponentColor_CALL_INSTANCE;

typedef struct _CMOCK_SetCurrentComponentSaturation_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvDataComponentColor_t Expected_blSaturationColor;
  int Expected_saturation;

} CMOCK_SetCurrentComponentSaturation_CALL_INSTANCE;

typedef struct _CMOCK_GetCurrentComponentSaturation_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvDataComponentColor_t Expected_blSaturationColor;
  int* Expected_saturation;

} CMOCK_GetCurrentComponentSaturation_CALL_INSTANCE;

typedef struct _CMOCK_SetCurrentComponentHue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvDataComponentColor_t Expected_blHueColor;
  int Expected_hue;

} CMOCK_SetCurrentComponentHue_CALL_INSTANCE;

typedef struct _CMOCK_GetCurrentComponentHue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvDataComponentColor_t Expected_blHueColor;
  int* Expected_hue;

} CMOCK_GetCurrentComponentHue_CALL_INSTANCE;

typedef struct _CMOCK_SetCurrentComponentLuma_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvDataComponentColor_t Expected_blLumaColor;
  int Expected_Luma;

} CMOCK_SetCurrentComponentLuma_CALL_INSTANCE;

typedef struct _CMOCK_GetCurrentComponentLuma_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvDataComponentColor_t Expected_blLumaColor;
  int* Expected_Luma;

} CMOCK_GetCurrentComponentLuma_CALL_INSTANCE;

typedef struct _CMOCK_GetTVSupportedDimmingModes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  char** Expected_dimmingModes;
  unsigned short* Expected_count;

} CMOCK_GetTVSupportedDimmingModes_CALL_INSTANCE;

typedef struct _CMOCK_SetTVDimmingMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  const char* Expected_dimmingMode;

} CMOCK_SetTVDimmingMode_CALL_INSTANCE;

typedef struct _CMOCK_GetTVBacklightGlobalFactor_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_value;

} CMOCK_GetTVBacklightGlobalFactor_CALL_INSTANCE;

typedef struct _CMOCK_SetTVBacklightGlobalFactor_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_value;
  int Expected_rangeMidPointValue;

} CMOCK_SetTVBacklightGlobalFactor_CALL_INSTANCE;

typedef struct _CMOCK_GetTVPictureModeIndex_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvPictureMode_t ReturnVal;
  const char* Expected_pictureMode;

} CMOCK_GetTVPictureModeIndex_CALL_INSTANCE;

typedef struct _CMOCK_GetCurrentContentFormat_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvVideoHDRFormat_t ReturnVal;

} CMOCK_GetCurrentContentFormat_CALL_INSTANCE;

typedef struct _CMOCK_GetSupportedContentFormats_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  unsigned int* Expected_contentFormats;
  unsigned short* Expected_numberOfFormats;

} CMOCK_GetSupportedContentFormats_CALL_INSTANCE;

typedef struct _CMOCK_ResetBrightness_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_defaultValue;
  bool Expected_resetForAllFormats;

} CMOCK_ResetBrightness_CALL_INSTANCE;

typedef struct _CMOCK_ResetContrast_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_defaultValue;
  bool Expected_resetForAllFormats;

} CMOCK_ResetContrast_CALL_INSTANCE;

typedef struct _CMOCK_ResetSharpness_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_defaultValue;
  bool Expected_resetForAllFormats;

} CMOCK_ResetSharpness_CALL_INSTANCE;

typedef struct _CMOCK_ResetSaturation_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_defaultValue;
  bool Expected_resetForAllFormats;

} CMOCK_ResetSaturation_CALL_INSTANCE;

typedef struct _CMOCK_ResetHue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_defaultValue;
  bool Expected_resetForAllFormats;

} CMOCK_ResetHue_CALL_INSTANCE;

typedef struct _CMOCK_ResetBacklight_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_defaultValue;
  bool Expected_resetForAllFormats;

} CMOCK_ResetBacklight_CALL_INSTANCE;

typedef struct _CMOCK_ResetColorTemperature_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_defaultValue;
  bool Expected_resetForAllFormats;

} CMOCK_ResetColorTemperature_CALL_INSTANCE;

typedef struct _CMOCK_ResetComponentSaturation_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_color;
  int Expected_defaultValue;

} CMOCK_ResetComponentSaturation_CALL_INSTANCE;

typedef struct _CMOCK_ResetComponentLuma_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_color;
  int Expected_defaultValue;

} CMOCK_ResetComponentLuma_CALL_INSTANCE;

typedef struct _CMOCK_ResetComponentHue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_color;
  int Expected_defaultValue;

} CMOCK_ResetComponentHue_CALL_INSTANCE;

typedef struct _CMOCK_isCurrentHDRTypeIsSDR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool ReturnVal;

} CMOCK_isCurrentHDRTypeIsSDR_CALL_INSTANCE;

typedef struct _CMOCK_GetPanelID_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  char* Expected_panelid;

} CMOCK_GetPanelID_CALL_INSTANCE;

typedef struct _CMOCK_GetDefaultPanelID_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char* Expected_panelID;

} CMOCK_GetDefaultPanelID_CALL_INSTANCE;

typedef struct _CMOCK_SaveColorTemperature_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sourceInput;
  int Expected_pq_mode;
  int Expected_hdr_type;
  int Expected_value;

} CMOCK_SaveColorTemperature_CALL_INSTANCE;

typedef struct _CMOCK_SaveBacklight_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sourceInput;
  int Expected_pq_mode;
  int Expected_hdr_type;
  int Expected_value;

} CMOCK_SaveBacklight_CALL_INSTANCE;

typedef struct _CMOCK_SaveContrast_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sourceInput;
  int Expected_pq_mode;
  int Expected_hdr_type;
  int Expected_value;

} CMOCK_SaveContrast_CALL_INSTANCE;

typedef struct _CMOCK_SaveSaturation_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sourceInput;
  int Expected_pq_mode;
  int Expected_hdr_type;
  int Expected_value;

} CMOCK_SaveSaturation_CALL_INSTANCE;

typedef struct _CMOCK_SaveSharpness_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sourceInput;
  int Expected_pq_mode;
  int Expected_hdr_type;
  int Expected_value;

} CMOCK_SaveSharpness_CALL_INSTANCE;

typedef struct _CMOCK_SaveBrightness_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sourceInput;
  int Expected_pq_mode;
  int Expected_hdr_type;
  int Expected_value;

} CMOCK_SaveBrightness_CALL_INSTANCE;

typedef struct _CMOCK_SaveHue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sourceInput;
  int Expected_pq_mode;
  int Expected_hdr_type;
  int Expected_value;

} CMOCK_SaveHue_CALL_INSTANCE;

typedef struct _CMOCK_SaveDynamicBacklight_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sourceInput;
  int Expected_pq_mode;
  int Expected_hdr_type;
  int Expected_value;

} CMOCK_SaveDynamicBacklight_CALL_INSTANCE;

typedef struct _CMOCK_SaveDisplayMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sourceInput;
  int Expected_pq_mode;
  int Expected_hdr_type;
  int Expected_value;

} CMOCK_SaveDisplayMode_CALL_INSTANCE;

typedef struct _CMOCK_SaveCMS_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sourceInput;
  int Expected_pq_mode;
  int Expected_hdr_type;
  int Expected_tunnel_type;
  int Expected_color_type;
  int Expected_value;

} CMOCK_SaveCMS_CALL_INSTANCE;

typedef struct _CMOCK_SaveDolbyMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sourceInput;
  int Expected_pq_mode;
  int Expected_hdr_type;
  int Expected_value;

} CMOCK_SaveDolbyMode_CALL_INSTANCE;

typedef struct _CMOCK_GetNumberOfModesupported_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;

} CMOCK_GetNumberOfModesupported_CALL_INSTANCE;

typedef struct _CMOCK_GetCurrentPQIndex_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;

} CMOCK_GetCurrentPQIndex_CALL_INSTANCE;

typedef struct _CMOCK_GetAllSupportedPicModeIndex_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int* Expected_pic_mode_index;

} CMOCK_GetAllSupportedPicModeIndex_CALL_INSTANCE;

typedef struct _CMOCK_GetCMSDefault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  tvCMS_tunel_t Expected_color_tunel_type;

} CMOCK_GetCMSDefault_CALL_INSTANCE;

typedef struct _CMOCK_GetDolbyModeIndex_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  const char* Expected_dolbyMode;

} CMOCK_GetDolbyModeIndex_CALL_INSTANCE;

typedef struct _CMOCK_ConvertVideoFormatToHDRFormat_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  tvVideoHDRFormat_t Expected_videoFormat;

} CMOCK_ConvertVideoFormatToHDRFormat_CALL_INSTANCE;

typedef struct _CMOCK_ConvertTVColorToVendorColor_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  tvDataComponentColor_t Expected_blComponentColor;

} CMOCK_ConvertTVColorToVendorColor_CALL_INSTANCE;

typedef struct _CMOCK_ConvertHDRFormatToContentFormat_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  tvhdr_type_t Expected_hdrFormat;

} CMOCK_ConvertHDRFormatToContentFormat_CALL_INSTANCE;

typedef struct _CMOCK_GetCustomPQModeIndex_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;

} CMOCK_GetCustomPQModeIndex_CALL_INSTANCE;

typedef struct _CMOCK_SetCMSState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvCMS_tunel_t Expected_tunelType;
  tvcomponent_color_type_t Expected_colorType;
  tvcomponent_state_t Expected_componentState;

} CMOCK_SetCMSState_CALL_INSTANCE;

typedef struct _CMOCK_isWBUserDfault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool ReturnVal;
  tvDataColor_t Expected_wbvalue;

} CMOCK_isWBUserDfault_CALL_INSTANCE;

typedef struct _CMOCK_GetWBRgbType_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  const char* Expected_color;
  const char* Expected_ctrl;

} CMOCK_GetWBRgbType_CALL_INSTANCE;

typedef struct _CMOCK_GetUSerWBValueOnInit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvDataColor_t ReturnVal;

} CMOCK_GetUSerWBValueOnInit_CALL_INSTANCE;

typedef struct _CMOCK_areEqual_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool ReturnVal;
  tvDataColor_t Expected_wbvalueThis;
  tvDataColor_t Expected_wbvalueThat;

} CMOCK_areEqual_CALL_INSTANCE;

typedef struct _CMOCK_SetColorTemperatureUser_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_rgbType;
  int Expected_value;

} CMOCK_SetColorTemperatureUser_CALL_INSTANCE;

typedef struct _CMOCK_SaveColorTemperatureUser_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_rgbType;
  int Expected_value;

} CMOCK_SaveColorTemperatureUser_CALL_INSTANCE;

typedef struct _CMOCK_SetBacklightInfo_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  tvBacklightInfo_t Expected_backlightDefaults;

} CMOCK_SetBacklightInfo_CALL_INSTANCE;

typedef struct _CMOCK_GetDriverEquivalentBLForCurrentFmt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  int Expected_backlight;

} CMOCK_GetDriverEquivalentBLForCurrentFmt_CALL_INSTANCE;

typedef struct _CMOCK_GetHLGModeIndex_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  const char* Expected_hlgMode;

} CMOCK_GetHLGModeIndex_CALL_INSTANCE;

typedef struct _CMOCK_GetHDR10ModeIndex_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  const char* Expected_hdr10Mode;

} CMOCK_GetHDR10ModeIndex_CALL_INSTANCE;

typedef struct _CMOCK_SetBacklightFade_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_from;
  int Expected_to;
  int Expected_duration;

} CMOCK_SetBacklightFade_CALL_INSTANCE;

typedef struct _CMOCK_ReadAllModeConfigfile_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  const char* Expected_file;
  char* Expected_cpybuffer;
  const char* Expected_searchstring;

} CMOCK_ReadAllModeConfigfile_CALL_INSTANCE;

typedef struct _CMOCK_splitstringsfrombuffer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char* Expected_buffer;
  char* Expected_availableModes;
  unsigned short* Expected_totalcount;

} CMOCK_splitstringsfrombuffer_CALL_INSTANCE;

typedef struct _CMOCK_splitstringsandvaluefrombuffer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char* Expected_buffer;
  pic_modes_t** Expected_availableModes;
  unsigned short* Expected_totalcount;

} CMOCK_splitstringsandvaluefrombuffer_CALL_INSTANCE;

typedef struct _CMOCK_SetGammaMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_mode;

} CMOCK_SetGammaMode_CALL_INSTANCE;

typedef struct _CMOCK_SetLocalDimmingLevel_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_localDimmingLevel;

} CMOCK_SetLocalDimmingLevel_CALL_INSTANCE;

typedef struct _CMOCK_GetLocalDimmingLevel_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int* Expected_localDimmingLevel;

} CMOCK_GetLocalDimmingLevel_CALL_INSTANCE;

typedef struct _CMOCK_SaveLocalDimmingLevel_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_sourceInput;
  int Expected_pq_mode;
  int Expected_hdr_type;
  int Expected_value;

} CMOCK_SaveLocalDimmingLevel_CALL_INSTANCE;

typedef struct _CMOCK_SwitchEDID_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int Expected_pqmode;

} CMOCK_SwitchEDID_CALL_INSTANCE;

typedef struct _CMOCK_UpdateEDIDAndSetDimmingLevel_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  tvError_t ReturnVal;
  int Expected_dimmingLevel;

} CMOCK_UpdateEDIDAndSetDimmingLevel_CALL_INSTANCE;

typedef struct _CMOCK_GetLDIMAndEDIDLevel_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int Expected_dimmingMode;
  int Expected_format;
  int* Expected_dimmingLevel;
  int* Expected_edidLevel;

} CMOCK_GetLDIMAndEDIDLevel_CALL_INSTANCE;

static struct MocktvSettingsInstance
{
  CMOCK_MEM_INDEX_TYPE tvInit_CallInstance;
  CMOCK_MEM_INDEX_TYPE tvSD3toCriSyncInit_CallInstance;
  CMOCK_MEM_INDEX_TYPE tvTerm_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetTVPictureMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetTVPictureMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetBacklight_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetBacklight_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetBrightness_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetBrightness_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetContrast_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetContrast_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetSharpness_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetSharpness_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetSaturation_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetSaturation_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetHue_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetHue_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemperature_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemperature_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetAspectRatio_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetAspectRatio_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetTint_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetTint_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetSupportedBacklightModes_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetCurrentBacklightMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetCurrentBacklightMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetCurrentVideoFormat_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetVideoResolution_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetVideoFrameRate_CallInstance;
  CMOCK_MEM_INDEX_TYPE setWakeupConfig_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetRGBPattern_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetRGBPattern_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetGrayPattern_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetGrayPattern_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemp_Rgain_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemp_Rgain_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemp_Ggain_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemp_Ggain_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemp_Bgain_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemp_Bgain_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemp_R_post_offset_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemp_R_post_offset_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemp_G_post_offset_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemp_G_post_offset_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemp_B_post_offset_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemp_B_post_offset_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetTVSupportedPictureModes_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetTVSupportedDVModes_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetTVDolbyVisionMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetTVDolbyVisionMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetTVHLGMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetTVHDR10Mode_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetTVHLGMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetTVHDR10Mode_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetTVSupportedHLGModes_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetTVSupportedHDR10Modes_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetDynamicContrast_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetDynamicContrast_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemp_Rgain_onSource_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemp_Rgain_onSource_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemp_Ggain_onSource_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemp_Ggain_onSource_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemp_Bgain_onSource_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemp_Bgain_onSource_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemp_R_post_offset_onSource_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemp_R_post_offset_onSource_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemp_G_post_offset_onSource_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemp_G_post_offset_onSource_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemp_B_post_offset_onSource_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetColorTemp_B_post_offset_onSource_CallInstance;
  CMOCK_MEM_INDEX_TYPE setWBctrl_CallInstance;
  CMOCK_MEM_INDEX_TYPE getWBctrl_CallInstance;
  CMOCK_MEM_INDEX_TYPE enableWBmode_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetSupportedComponentColor_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetCurrentComponentSaturation_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetCurrentComponentSaturation_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetCurrentComponentHue_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetCurrentComponentHue_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetCurrentComponentLuma_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetCurrentComponentLuma_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetTVSupportedDimmingModes_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetTVDimmingMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetTVBacklightGlobalFactor_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetTVBacklightGlobalFactor_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetTVPictureModeIndex_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetCurrentContentFormat_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetSupportedContentFormats_CallInstance;
  CMOCK_MEM_INDEX_TYPE ResetBrightness_CallInstance;
  CMOCK_MEM_INDEX_TYPE ResetContrast_CallInstance;
  CMOCK_MEM_INDEX_TYPE ResetSharpness_CallInstance;
  CMOCK_MEM_INDEX_TYPE ResetSaturation_CallInstance;
  CMOCK_MEM_INDEX_TYPE ResetHue_CallInstance;
  CMOCK_MEM_INDEX_TYPE ResetBacklight_CallInstance;
  CMOCK_MEM_INDEX_TYPE ResetColorTemperature_CallInstance;
  CMOCK_MEM_INDEX_TYPE ResetComponentSaturation_CallInstance;
  CMOCK_MEM_INDEX_TYPE ResetComponentLuma_CallInstance;
  CMOCK_MEM_INDEX_TYPE ResetComponentHue_CallInstance;
  CMOCK_MEM_INDEX_TYPE isCurrentHDRTypeIsSDR_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetPanelID_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetDefaultPanelID_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveColorTemperature_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveBacklight_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveContrast_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveSaturation_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveSharpness_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveBrightness_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveHue_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveDynamicBacklight_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveDisplayMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveCMS_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveDolbyMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetNumberOfModesupported_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetCurrentPQIndex_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetAllSupportedPicModeIndex_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetCMSDefault_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetDolbyModeIndex_CallInstance;
  CMOCK_MEM_INDEX_TYPE ConvertVideoFormatToHDRFormat_CallInstance;
  CMOCK_MEM_INDEX_TYPE ConvertTVColorToVendorColor_CallInstance;
  CMOCK_MEM_INDEX_TYPE ConvertHDRFormatToContentFormat_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetCustomPQModeIndex_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetCMSState_CallInstance;
  CMOCK_MEM_INDEX_TYPE isWBUserDfault_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetWBRgbType_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetUSerWBValueOnInit_CallInstance;
  CMOCK_MEM_INDEX_TYPE areEqual_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetColorTemperatureUser_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveColorTemperatureUser_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetBacklightInfo_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetDriverEquivalentBLForCurrentFmt_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetHLGModeIndex_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetHDR10ModeIndex_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetBacklightFade_CallInstance;
  CMOCK_MEM_INDEX_TYPE ReadAllModeConfigfile_CallInstance;
  CMOCK_MEM_INDEX_TYPE splitstringsfrombuffer_CallInstance;
  CMOCK_MEM_INDEX_TYPE splitstringsandvaluefrombuffer_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetGammaMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE SetLocalDimmingLevel_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetLocalDimmingLevel_CallInstance;
  CMOCK_MEM_INDEX_TYPE SaveLocalDimmingLevel_CallInstance;
  CMOCK_MEM_INDEX_TYPE SwitchEDID_CallInstance;
  CMOCK_MEM_INDEX_TYPE UpdateEDIDAndSetDimmingLevel_CallInstance;
  CMOCK_MEM_INDEX_TYPE GetLDIMAndEDIDLevel_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void MocktvSettings_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.tvInit_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_tvInit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.tvSD3toCriSyncInit_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_tvSD3toCriSyncInit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.tvTerm_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_tvTerm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetTVPictureMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetTVPictureMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetTVPictureMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetTVPictureMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetBacklight_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetBacklight);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetBacklight_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetBacklight);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetBrightness_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetBrightness);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetBrightness_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetBrightness);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetContrast_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetContrast);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetContrast_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetContrast);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetSharpness_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetSharpness);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetSharpness_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetSharpness);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetSaturation_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetSaturation);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetSaturation_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetSaturation);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetHue_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetHue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetHue_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetHue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemperature_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemperature);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemperature_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemperature);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetAspectRatio_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetAspectRatio);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetAspectRatio_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetAspectRatio);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetTint_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetTint);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetTint_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetTint);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetSupportedBacklightModes_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetSupportedBacklightModes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetCurrentBacklightMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetCurrentBacklightMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetCurrentBacklightMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetCurrentBacklightMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetCurrentVideoFormat_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetCurrentVideoFormat);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetVideoResolution_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetVideoResolution);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetVideoFrameRate_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetVideoFrameRate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.setWakeupConfig_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_setWakeupConfig);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetRGBPattern_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetRGBPattern);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetRGBPattern_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetRGBPattern);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetGrayPattern_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetGrayPattern);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetGrayPattern_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetGrayPattern);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemp_Rgain_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemp_Rgain);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemp_Rgain_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemp_Rgain);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemp_Ggain_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemp_Ggain);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemp_Ggain_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemp_Ggain);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemp_Bgain_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemp_Bgain);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemp_Bgain_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemp_Bgain);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemp_R_post_offset_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemp_R_post_offset);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemp_R_post_offset_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemp_R_post_offset);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemp_G_post_offset_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemp_G_post_offset);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemp_G_post_offset_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemp_G_post_offset);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemp_B_post_offset_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemp_B_post_offset);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemp_B_post_offset_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemp_B_post_offset);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetTVSupportedPictureModes_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetTVSupportedPictureModes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetTVSupportedDVModes_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetTVSupportedDVModes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetTVDolbyVisionMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetTVDolbyVisionMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetTVDolbyVisionMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetTVDolbyVisionMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetTVHLGMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetTVHLGMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetTVHDR10Mode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetTVHDR10Mode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetTVHLGMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetTVHLGMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetTVHDR10Mode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetTVHDR10Mode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetTVSupportedHLGModes_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetTVSupportedHLGModes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetTVSupportedHDR10Modes_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetTVSupportedHDR10Modes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetDynamicContrast_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetDynamicContrast);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetDynamicContrast_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetDynamicContrast);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemp_Rgain_onSource_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemp_Rgain_onSource);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemp_Rgain_onSource_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemp_Rgain_onSource);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemp_Ggain_onSource_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemp_Ggain_onSource);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemp_Ggain_onSource_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemp_Ggain_onSource);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemp_Bgain_onSource_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemp_Bgain_onSource);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemp_Bgain_onSource_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemp_Bgain_onSource);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemp_R_post_offset_onSource_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemp_R_post_offset_onSource);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemp_R_post_offset_onSource_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemp_R_post_offset_onSource);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemp_G_post_offset_onSource_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemp_G_post_offset_onSource);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemp_G_post_offset_onSource_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemp_G_post_offset_onSource);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemp_B_post_offset_onSource_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemp_B_post_offset_onSource);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetColorTemp_B_post_offset_onSource_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetColorTemp_B_post_offset_onSource);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.setWBctrl_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_setWBctrl);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.getWBctrl_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_getWBctrl);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.enableWBmode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_enableWBmode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetSupportedComponentColor_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetSupportedComponentColor);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetCurrentComponentSaturation_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetCurrentComponentSaturation);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetCurrentComponentSaturation_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetCurrentComponentSaturation);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetCurrentComponentHue_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetCurrentComponentHue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetCurrentComponentHue_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetCurrentComponentHue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetCurrentComponentLuma_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetCurrentComponentLuma);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetCurrentComponentLuma_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetCurrentComponentLuma);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetTVSupportedDimmingModes_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetTVSupportedDimmingModes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetTVDimmingMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetTVDimmingMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetTVBacklightGlobalFactor_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetTVBacklightGlobalFactor);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetTVBacklightGlobalFactor_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetTVBacklightGlobalFactor);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetTVPictureModeIndex_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetTVPictureModeIndex);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetCurrentContentFormat_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetCurrentContentFormat);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetSupportedContentFormats_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetSupportedContentFormats);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ResetBrightness_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ResetBrightness);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ResetContrast_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ResetContrast);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ResetSharpness_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ResetSharpness);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ResetSaturation_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ResetSaturation);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ResetHue_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ResetHue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ResetBacklight_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ResetBacklight);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ResetColorTemperature_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ResetColorTemperature);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ResetComponentSaturation_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ResetComponentSaturation);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ResetComponentLuma_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ResetComponentLuma);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ResetComponentHue_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ResetComponentHue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.isCurrentHDRTypeIsSDR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_isCurrentHDRTypeIsSDR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetPanelID_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetPanelID);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetDefaultPanelID_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetDefaultPanelID);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveColorTemperature_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveColorTemperature);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveBacklight_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveBacklight);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveContrast_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveContrast);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveSaturation_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveSaturation);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveSharpness_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveSharpness);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveBrightness_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveBrightness);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveHue_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveHue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveDynamicBacklight_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveDynamicBacklight);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveDisplayMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveDisplayMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveCMS_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveCMS);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveDolbyMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveDolbyMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetNumberOfModesupported_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetNumberOfModesupported);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetCurrentPQIndex_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetCurrentPQIndex);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetAllSupportedPicModeIndex_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetAllSupportedPicModeIndex);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetCMSDefault_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetCMSDefault);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetDolbyModeIndex_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetDolbyModeIndex);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ConvertVideoFormatToHDRFormat_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ConvertVideoFormatToHDRFormat);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ConvertTVColorToVendorColor_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ConvertTVColorToVendorColor);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ConvertHDRFormatToContentFormat_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ConvertHDRFormatToContentFormat);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetCustomPQModeIndex_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetCustomPQModeIndex);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetCMSState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetCMSState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.isWBUserDfault_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_isWBUserDfault);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetWBRgbType_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetWBRgbType);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetUSerWBValueOnInit_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetUSerWBValueOnInit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.areEqual_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_areEqual);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetColorTemperatureUser_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetColorTemperatureUser);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveColorTemperatureUser_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveColorTemperatureUser);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetBacklightInfo_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetBacklightInfo);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetDriverEquivalentBLForCurrentFmt_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetDriverEquivalentBLForCurrentFmt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetHLGModeIndex_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetHLGModeIndex);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetHDR10ModeIndex_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetHDR10ModeIndex);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetBacklightFade_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetBacklightFade);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ReadAllModeConfigfile_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ReadAllModeConfigfile);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.splitstringsfrombuffer_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_splitstringsfrombuffer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.splitstringsandvaluefrombuffer_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_splitstringsandvaluefrombuffer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetGammaMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetGammaMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SetLocalDimmingLevel_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SetLocalDimmingLevel);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetLocalDimmingLevel_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetLocalDimmingLevel);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SaveLocalDimmingLevel_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SaveLocalDimmingLevel);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.SwitchEDID_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_SwitchEDID);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.UpdateEDIDAndSetDimmingLevel_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_UpdateEDIDAndSetDimmingLevel);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.GetLDIMAndEDIDLevel_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GetLDIMAndEDIDLevel);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void MocktvSettings_Init(void)
{
  MocktvSettings_Destroy();
}

void MocktvSettings_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

tvError_t tvInit(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_tvInit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_tvInit);
  cmock_call_instance = (CMOCK_tvInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.tvInit_CallInstance);
  Mock.tvInit_CallInstance = CMock_Guts_MemNext(Mock.tvInit_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void tvInit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_tvInit_CALL_INSTANCE));
  CMOCK_tvInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_tvInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.tvInit_CallInstance = CMock_Guts_MemChain(Mock.tvInit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t tvSD3toCriSyncInit(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_tvSD3toCriSyncInit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_tvSD3toCriSyncInit);
  cmock_call_instance = (CMOCK_tvSD3toCriSyncInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.tvSD3toCriSyncInit_CallInstance);
  Mock.tvSD3toCriSyncInit_CallInstance = CMock_Guts_MemNext(Mock.tvSD3toCriSyncInit_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void tvSD3toCriSyncInit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_tvSD3toCriSyncInit_CALL_INSTANCE));
  CMOCK_tvSD3toCriSyncInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_tvSD3toCriSyncInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.tvSD3toCriSyncInit_CallInstance = CMock_Guts_MemChain(Mock.tvSD3toCriSyncInit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t tvTerm(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_tvTerm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_tvTerm);
  cmock_call_instance = (CMOCK_tvTerm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.tvTerm_CallInstance);
  Mock.tvTerm_CallInstance = CMock_Guts_MemNext(Mock.tvTerm_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void tvTerm_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_tvTerm_CALL_INSTANCE));
  CMOCK_tvTerm_CALL_INSTANCE* cmock_call_instance = (CMOCK_tvTerm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.tvTerm_CallInstance = CMock_Guts_MemChain(Mock.tvTerm_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetTVPictureMode(char* pictureMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetTVPictureMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetTVPictureMode);
  cmock_call_instance = (CMOCK_GetTVPictureMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetTVPictureMode_CallInstance);
  Mock.GetTVPictureMode_CallInstance = CMock_Guts_MemNext(Mock.GetTVPictureMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetTVPictureMode,CMockString_pictureMode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pictureMode, pictureMode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetTVPictureMode(CMOCK_GetTVPictureMode_CALL_INSTANCE* cmock_call_instance, char* pictureMode);
void CMockExpectParameters_GetTVPictureMode(CMOCK_GetTVPictureMode_CALL_INSTANCE* cmock_call_instance, char* pictureMode)
{
  cmock_call_instance->Expected_pictureMode = pictureMode;
}

void GetTVPictureMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* pictureMode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetTVPictureMode_CALL_INSTANCE));
  CMOCK_GetTVPictureMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetTVPictureMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetTVPictureMode_CallInstance = CMock_Guts_MemChain(Mock.GetTVPictureMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetTVPictureMode(cmock_call_instance, pictureMode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetTVPictureMode(const char* pictureMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetTVPictureMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetTVPictureMode);
  cmock_call_instance = (CMOCK_SetTVPictureMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetTVPictureMode_CallInstance);
  Mock.SetTVPictureMode_CallInstance = CMock_Guts_MemNext(Mock.SetTVPictureMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetTVPictureMode,CMockString_pictureMode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pictureMode, pictureMode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetTVPictureMode(CMOCK_SetTVPictureMode_CALL_INSTANCE* cmock_call_instance, const char* pictureMode);
void CMockExpectParameters_SetTVPictureMode(CMOCK_SetTVPictureMode_CALL_INSTANCE* cmock_call_instance, const char* pictureMode)
{
  cmock_call_instance->Expected_pictureMode = pictureMode;
}

void SetTVPictureMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* pictureMode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetTVPictureMode_CALL_INSTANCE));
  CMOCK_SetTVPictureMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetTVPictureMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetTVPictureMode_CallInstance = CMock_Guts_MemChain(Mock.SetTVPictureMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetTVPictureMode(cmock_call_instance, pictureMode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetBacklight(int* backlight)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetBacklight_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetBacklight);
  cmock_call_instance = (CMOCK_GetBacklight_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetBacklight_CallInstance);
  Mock.GetBacklight_CallInstance = CMock_Guts_MemNext(Mock.GetBacklight_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetBacklight,CMockString_backlight);
    if (cmock_call_instance->Expected_backlight == NULL)
      { UNITY_TEST_ASSERT_NULL(backlight, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_backlight, backlight, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetBacklight(CMOCK_GetBacklight_CALL_INSTANCE* cmock_call_instance, int* backlight);
void CMockExpectParameters_GetBacklight(CMOCK_GetBacklight_CALL_INSTANCE* cmock_call_instance, int* backlight)
{
  cmock_call_instance->Expected_backlight = backlight;
}

void GetBacklight_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* backlight, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetBacklight_CALL_INSTANCE));
  CMOCK_GetBacklight_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetBacklight_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetBacklight_CallInstance = CMock_Guts_MemChain(Mock.GetBacklight_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetBacklight(cmock_call_instance, backlight);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetBacklight(int backlight)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetBacklight_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetBacklight);
  cmock_call_instance = (CMOCK_SetBacklight_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetBacklight_CallInstance);
  Mock.SetBacklight_CallInstance = CMock_Guts_MemNext(Mock.SetBacklight_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetBacklight,CMockString_backlight);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_backlight, backlight, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetBacklight(CMOCK_SetBacklight_CALL_INSTANCE* cmock_call_instance, int backlight);
void CMockExpectParameters_SetBacklight(CMOCK_SetBacklight_CALL_INSTANCE* cmock_call_instance, int backlight)
{
  cmock_call_instance->Expected_backlight = backlight;
}

void SetBacklight_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int backlight, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetBacklight_CALL_INSTANCE));
  CMOCK_SetBacklight_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetBacklight_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetBacklight_CallInstance = CMock_Guts_MemChain(Mock.SetBacklight_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetBacklight(cmock_call_instance, backlight);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetBrightness(int brightness)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetBrightness_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetBrightness);
  cmock_call_instance = (CMOCK_SetBrightness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetBrightness_CallInstance);
  Mock.SetBrightness_CallInstance = CMock_Guts_MemNext(Mock.SetBrightness_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetBrightness,CMockString_brightness);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_brightness, brightness, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetBrightness(CMOCK_SetBrightness_CALL_INSTANCE* cmock_call_instance, int brightness);
void CMockExpectParameters_SetBrightness(CMOCK_SetBrightness_CALL_INSTANCE* cmock_call_instance, int brightness)
{
  cmock_call_instance->Expected_brightness = brightness;
}

void SetBrightness_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int brightness, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetBrightness_CALL_INSTANCE));
  CMOCK_SetBrightness_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetBrightness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetBrightness_CallInstance = CMock_Guts_MemChain(Mock.SetBrightness_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetBrightness(cmock_call_instance, brightness);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetBrightness(int* brightness)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetBrightness_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetBrightness);
  cmock_call_instance = (CMOCK_GetBrightness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetBrightness_CallInstance);
  Mock.GetBrightness_CallInstance = CMock_Guts_MemNext(Mock.GetBrightness_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetBrightness,CMockString_brightness);
    if (cmock_call_instance->Expected_brightness == NULL)
      { UNITY_TEST_ASSERT_NULL(brightness, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_brightness, brightness, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetBrightness(CMOCK_GetBrightness_CALL_INSTANCE* cmock_call_instance, int* brightness);
void CMockExpectParameters_GetBrightness(CMOCK_GetBrightness_CALL_INSTANCE* cmock_call_instance, int* brightness)
{
  cmock_call_instance->Expected_brightness = brightness;
}

void GetBrightness_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* brightness, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetBrightness_CALL_INSTANCE));
  CMOCK_GetBrightness_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetBrightness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetBrightness_CallInstance = CMock_Guts_MemChain(Mock.GetBrightness_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetBrightness(cmock_call_instance, brightness);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetContrast(int contrast)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetContrast_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetContrast);
  cmock_call_instance = (CMOCK_SetContrast_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetContrast_CallInstance);
  Mock.SetContrast_CallInstance = CMock_Guts_MemNext(Mock.SetContrast_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetContrast,CMockString_contrast);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_contrast, contrast, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetContrast(CMOCK_SetContrast_CALL_INSTANCE* cmock_call_instance, int contrast);
void CMockExpectParameters_SetContrast(CMOCK_SetContrast_CALL_INSTANCE* cmock_call_instance, int contrast)
{
  cmock_call_instance->Expected_contrast = contrast;
}

void SetContrast_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int contrast, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetContrast_CALL_INSTANCE));
  CMOCK_SetContrast_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetContrast_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetContrast_CallInstance = CMock_Guts_MemChain(Mock.SetContrast_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetContrast(cmock_call_instance, contrast);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetContrast(int* contrast)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetContrast_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetContrast);
  cmock_call_instance = (CMOCK_GetContrast_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetContrast_CallInstance);
  Mock.GetContrast_CallInstance = CMock_Guts_MemNext(Mock.GetContrast_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetContrast,CMockString_contrast);
    if (cmock_call_instance->Expected_contrast == NULL)
      { UNITY_TEST_ASSERT_NULL(contrast, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_contrast, contrast, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetContrast(CMOCK_GetContrast_CALL_INSTANCE* cmock_call_instance, int* contrast);
void CMockExpectParameters_GetContrast(CMOCK_GetContrast_CALL_INSTANCE* cmock_call_instance, int* contrast)
{
  cmock_call_instance->Expected_contrast = contrast;
}

void GetContrast_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* contrast, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetContrast_CALL_INSTANCE));
  CMOCK_GetContrast_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetContrast_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetContrast_CallInstance = CMock_Guts_MemChain(Mock.GetContrast_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetContrast(cmock_call_instance, contrast);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetSharpness(int sharpness)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetSharpness_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetSharpness);
  cmock_call_instance = (CMOCK_SetSharpness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetSharpness_CallInstance);
  Mock.SetSharpness_CallInstance = CMock_Guts_MemNext(Mock.SetSharpness_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetSharpness,CMockString_sharpness);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sharpness, sharpness, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetSharpness(CMOCK_SetSharpness_CALL_INSTANCE* cmock_call_instance, int sharpness);
void CMockExpectParameters_SetSharpness(CMOCK_SetSharpness_CALL_INSTANCE* cmock_call_instance, int sharpness)
{
  cmock_call_instance->Expected_sharpness = sharpness;
}

void SetSharpness_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sharpness, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetSharpness_CALL_INSTANCE));
  CMOCK_SetSharpness_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetSharpness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetSharpness_CallInstance = CMock_Guts_MemChain(Mock.SetSharpness_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetSharpness(cmock_call_instance, sharpness);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetSharpness(int* sharpness)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetSharpness_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetSharpness);
  cmock_call_instance = (CMOCK_GetSharpness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetSharpness_CallInstance);
  Mock.GetSharpness_CallInstance = CMock_Guts_MemNext(Mock.GetSharpness_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetSharpness,CMockString_sharpness);
    if (cmock_call_instance->Expected_sharpness == NULL)
      { UNITY_TEST_ASSERT_NULL(sharpness, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_sharpness, sharpness, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetSharpness(CMOCK_GetSharpness_CALL_INSTANCE* cmock_call_instance, int* sharpness);
void CMockExpectParameters_GetSharpness(CMOCK_GetSharpness_CALL_INSTANCE* cmock_call_instance, int* sharpness)
{
  cmock_call_instance->Expected_sharpness = sharpness;
}

void GetSharpness_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* sharpness, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetSharpness_CALL_INSTANCE));
  CMOCK_GetSharpness_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetSharpness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetSharpness_CallInstance = CMock_Guts_MemChain(Mock.GetSharpness_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetSharpness(cmock_call_instance, sharpness);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetSaturation(int saturation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetSaturation_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetSaturation);
  cmock_call_instance = (CMOCK_SetSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetSaturation_CallInstance);
  Mock.SetSaturation_CallInstance = CMock_Guts_MemNext(Mock.SetSaturation_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetSaturation,CMockString_saturation);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_saturation, saturation, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetSaturation(CMOCK_SetSaturation_CALL_INSTANCE* cmock_call_instance, int saturation);
void CMockExpectParameters_SetSaturation(CMOCK_SetSaturation_CALL_INSTANCE* cmock_call_instance, int saturation)
{
  cmock_call_instance->Expected_saturation = saturation;
}

void SetSaturation_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int saturation, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetSaturation_CALL_INSTANCE));
  CMOCK_SetSaturation_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetSaturation_CallInstance = CMock_Guts_MemChain(Mock.SetSaturation_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetSaturation(cmock_call_instance, saturation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetSaturation(int* saturation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetSaturation_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetSaturation);
  cmock_call_instance = (CMOCK_GetSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetSaturation_CallInstance);
  Mock.GetSaturation_CallInstance = CMock_Guts_MemNext(Mock.GetSaturation_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetSaturation,CMockString_saturation);
    if (cmock_call_instance->Expected_saturation == NULL)
      { UNITY_TEST_ASSERT_NULL(saturation, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_saturation, saturation, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetSaturation(CMOCK_GetSaturation_CALL_INSTANCE* cmock_call_instance, int* saturation);
void CMockExpectParameters_GetSaturation(CMOCK_GetSaturation_CALL_INSTANCE* cmock_call_instance, int* saturation)
{
  cmock_call_instance->Expected_saturation = saturation;
}

void GetSaturation_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* saturation, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetSaturation_CALL_INSTANCE));
  CMOCK_GetSaturation_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetSaturation_CallInstance = CMock_Guts_MemChain(Mock.GetSaturation_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetSaturation(cmock_call_instance, saturation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetHue(int hue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetHue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetHue);
  cmock_call_instance = (CMOCK_SetHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetHue_CallInstance);
  Mock.SetHue_CallInstance = CMock_Guts_MemNext(Mock.SetHue_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetHue,CMockString_hue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hue, hue, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetHue(CMOCK_SetHue_CALL_INSTANCE* cmock_call_instance, int hue);
void CMockExpectParameters_SetHue(CMOCK_SetHue_CALL_INSTANCE* cmock_call_instance, int hue)
{
  cmock_call_instance->Expected_hue = hue;
}

void SetHue_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int hue, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetHue_CALL_INSTANCE));
  CMOCK_SetHue_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetHue_CallInstance = CMock_Guts_MemChain(Mock.SetHue_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetHue(cmock_call_instance, hue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetHue(int* hue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetHue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetHue);
  cmock_call_instance = (CMOCK_GetHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetHue_CallInstance);
  Mock.GetHue_CallInstance = CMock_Guts_MemNext(Mock.GetHue_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetHue,CMockString_hue);
    if (cmock_call_instance->Expected_hue == NULL)
      { UNITY_TEST_ASSERT_NULL(hue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_hue, hue, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetHue(CMOCK_GetHue_CALL_INSTANCE* cmock_call_instance, int* hue);
void CMockExpectParameters_GetHue(CMOCK_GetHue_CALL_INSTANCE* cmock_call_instance, int* hue)
{
  cmock_call_instance->Expected_hue = hue;
}

void GetHue_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* hue, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetHue_CALL_INSTANCE));
  CMOCK_GetHue_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetHue_CallInstance = CMock_Guts_MemChain(Mock.GetHue_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetHue(cmock_call_instance, hue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemperature(tvColorTemp_t colorTemp)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemperature_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemperature);
  cmock_call_instance = (CMOCK_SetColorTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemperature_CallInstance);
  Mock.SetColorTemperature_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemperature_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemperature,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemperature(CMOCK_SetColorTemperature_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp);
void CMockExpectParameters_SetColorTemperature(CMOCK_SetColorTemperature_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
}

void SetColorTemperature_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemperature_CALL_INSTANCE));
  CMOCK_SetColorTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemperature_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemperature_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemperature(cmock_call_instance, colorTemp);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemperature(tvColorTemp_t* colorTemp)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemperature_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemperature);
  cmock_call_instance = (CMOCK_GetColorTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemperature_CallInstance);
  Mock.GetColorTemperature_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemperature_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemperature,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_colorTemp), (void*)(colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemperature(CMOCK_GetColorTemperature_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t* colorTemp);
void CMockExpectParameters_GetColorTemperature(CMOCK_GetColorTemperature_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t* colorTemp)
{
  cmock_call_instance->Expected_colorTemp = colorTemp;
}

void GetColorTemperature_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t* colorTemp, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemperature_CALL_INSTANCE));
  CMOCK_GetColorTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemperature_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemperature_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemperature(cmock_call_instance, colorTemp);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetAspectRatio(tvDisplayMode_t dispMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetAspectRatio_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetAspectRatio);
  cmock_call_instance = (CMOCK_SetAspectRatio_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetAspectRatio_CallInstance);
  Mock.SetAspectRatio_CallInstance = CMock_Guts_MemNext(Mock.SetAspectRatio_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetAspectRatio,CMockString_dispMode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_dispMode), (void*)(&dispMode), sizeof(tvDisplayMode_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetAspectRatio(CMOCK_SetAspectRatio_CALL_INSTANCE* cmock_call_instance, tvDisplayMode_t dispMode);
void CMockExpectParameters_SetAspectRatio(CMOCK_SetAspectRatio_CALL_INSTANCE* cmock_call_instance, tvDisplayMode_t dispMode)
{
  memcpy((void*)(&cmock_call_instance->Expected_dispMode), (void*)(&dispMode),
         sizeof(tvDisplayMode_t[sizeof(dispMode) == sizeof(tvDisplayMode_t) ? 1 : -1])); /* add tvDisplayMode_t to :treat_as_array if this causes an error */
}

void SetAspectRatio_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvDisplayMode_t dispMode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetAspectRatio_CALL_INSTANCE));
  CMOCK_SetAspectRatio_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetAspectRatio_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetAspectRatio_CallInstance = CMock_Guts_MemChain(Mock.SetAspectRatio_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetAspectRatio(cmock_call_instance, dispMode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetAspectRatio(tvDisplayMode_t* dispMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetAspectRatio_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetAspectRatio);
  cmock_call_instance = (CMOCK_GetAspectRatio_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetAspectRatio_CallInstance);
  Mock.GetAspectRatio_CallInstance = CMock_Guts_MemNext(Mock.GetAspectRatio_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetAspectRatio,CMockString_dispMode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_dispMode), (void*)(dispMode), sizeof(tvDisplayMode_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetAspectRatio(CMOCK_GetAspectRatio_CALL_INSTANCE* cmock_call_instance, tvDisplayMode_t* dispMode);
void CMockExpectParameters_GetAspectRatio(CMOCK_GetAspectRatio_CALL_INSTANCE* cmock_call_instance, tvDisplayMode_t* dispMode)
{
  cmock_call_instance->Expected_dispMode = dispMode;
}

void GetAspectRatio_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvDisplayMode_t* dispMode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetAspectRatio_CALL_INSTANCE));
  CMOCK_GetAspectRatio_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetAspectRatio_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetAspectRatio_CallInstance = CMock_Guts_MemChain(Mock.GetAspectRatio_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetAspectRatio(cmock_call_instance, dispMode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetTint(int* tint)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetTint_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetTint);
  cmock_call_instance = (CMOCK_GetTint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetTint_CallInstance);
  Mock.GetTint_CallInstance = CMock_Guts_MemNext(Mock.GetTint_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetTint,CMockString_tint);
    if (cmock_call_instance->Expected_tint == NULL)
      { UNITY_TEST_ASSERT_NULL(tint, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_tint, tint, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetTint(CMOCK_GetTint_CALL_INSTANCE* cmock_call_instance, int* tint);
void CMockExpectParameters_GetTint(CMOCK_GetTint_CALL_INSTANCE* cmock_call_instance, int* tint)
{
  cmock_call_instance->Expected_tint = tint;
}

void GetTint_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* tint, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetTint_CALL_INSTANCE));
  CMOCK_GetTint_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetTint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetTint_CallInstance = CMock_Guts_MemChain(Mock.GetTint_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetTint(cmock_call_instance, tint);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetTint(int tint)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetTint_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetTint);
  cmock_call_instance = (CMOCK_SetTint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetTint_CallInstance);
  Mock.SetTint_CallInstance = CMock_Guts_MemNext(Mock.SetTint_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetTint,CMockString_tint);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_tint, tint, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetTint(CMOCK_SetTint_CALL_INSTANCE* cmock_call_instance, int tint);
void CMockExpectParameters_SetTint(CMOCK_SetTint_CALL_INSTANCE* cmock_call_instance, int tint)
{
  cmock_call_instance->Expected_tint = tint;
}

void SetTint_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int tint, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetTint_CALL_INSTANCE));
  CMOCK_SetTint_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetTint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetTint_CallInstance = CMock_Guts_MemChain(Mock.SetTint_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetTint(cmock_call_instance, tint);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetSupportedBacklightModes(int* blModes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetSupportedBacklightModes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetSupportedBacklightModes);
  cmock_call_instance = (CMOCK_GetSupportedBacklightModes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetSupportedBacklightModes_CallInstance);
  Mock.GetSupportedBacklightModes_CallInstance = CMock_Guts_MemNext(Mock.GetSupportedBacklightModes_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetSupportedBacklightModes,CMockString_blModes);
    if (cmock_call_instance->Expected_blModes == NULL)
      { UNITY_TEST_ASSERT_NULL(blModes, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_blModes, blModes, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetSupportedBacklightModes(CMOCK_GetSupportedBacklightModes_CALL_INSTANCE* cmock_call_instance, int* blModes);
void CMockExpectParameters_GetSupportedBacklightModes(CMOCK_GetSupportedBacklightModes_CALL_INSTANCE* cmock_call_instance, int* blModes)
{
  cmock_call_instance->Expected_blModes = blModes;
}

void GetSupportedBacklightModes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* blModes, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetSupportedBacklightModes_CALL_INSTANCE));
  CMOCK_GetSupportedBacklightModes_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetSupportedBacklightModes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetSupportedBacklightModes_CallInstance = CMock_Guts_MemChain(Mock.GetSupportedBacklightModes_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetSupportedBacklightModes(cmock_call_instance, blModes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetCurrentBacklightMode(tvBacklightMode_t* blMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetCurrentBacklightMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetCurrentBacklightMode);
  cmock_call_instance = (CMOCK_GetCurrentBacklightMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetCurrentBacklightMode_CallInstance);
  Mock.GetCurrentBacklightMode_CallInstance = CMock_Guts_MemNext(Mock.GetCurrentBacklightMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetCurrentBacklightMode,CMockString_blMode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_blMode), (void*)(blMode), sizeof(tvBacklightMode_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetCurrentBacklightMode(CMOCK_GetCurrentBacklightMode_CALL_INSTANCE* cmock_call_instance, tvBacklightMode_t* blMode);
void CMockExpectParameters_GetCurrentBacklightMode(CMOCK_GetCurrentBacklightMode_CALL_INSTANCE* cmock_call_instance, tvBacklightMode_t* blMode)
{
  cmock_call_instance->Expected_blMode = blMode;
}

void GetCurrentBacklightMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvBacklightMode_t* blMode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetCurrentBacklightMode_CALL_INSTANCE));
  CMOCK_GetCurrentBacklightMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetCurrentBacklightMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetCurrentBacklightMode_CallInstance = CMock_Guts_MemChain(Mock.GetCurrentBacklightMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetCurrentBacklightMode(cmock_call_instance, blMode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetCurrentBacklightMode(tvBacklightMode_t blMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetCurrentBacklightMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetCurrentBacklightMode);
  cmock_call_instance = (CMOCK_SetCurrentBacklightMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetCurrentBacklightMode_CallInstance);
  Mock.SetCurrentBacklightMode_CallInstance = CMock_Guts_MemNext(Mock.SetCurrentBacklightMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetCurrentBacklightMode,CMockString_blMode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_blMode), (void*)(&blMode), sizeof(tvBacklightMode_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetCurrentBacklightMode(CMOCK_SetCurrentBacklightMode_CALL_INSTANCE* cmock_call_instance, tvBacklightMode_t blMode);
void CMockExpectParameters_SetCurrentBacklightMode(CMOCK_SetCurrentBacklightMode_CALL_INSTANCE* cmock_call_instance, tvBacklightMode_t blMode)
{
  memcpy((void*)(&cmock_call_instance->Expected_blMode), (void*)(&blMode),
         sizeof(tvBacklightMode_t[sizeof(blMode) == sizeof(tvBacklightMode_t) ? 1 : -1])); /* add tvBacklightMode_t to :treat_as_array if this causes an error */
}

void SetCurrentBacklightMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvBacklightMode_t blMode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetCurrentBacklightMode_CALL_INSTANCE));
  CMOCK_SetCurrentBacklightMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetCurrentBacklightMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetCurrentBacklightMode_CallInstance = CMock_Guts_MemChain(Mock.SetCurrentBacklightMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetCurrentBacklightMode(cmock_call_instance, blMode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetCurrentVideoFormat(tvVideoHDRFormat_t* format)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetCurrentVideoFormat_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetCurrentVideoFormat);
  cmock_call_instance = (CMOCK_GetCurrentVideoFormat_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetCurrentVideoFormat_CallInstance);
  Mock.GetCurrentVideoFormat_CallInstance = CMock_Guts_MemNext(Mock.GetCurrentVideoFormat_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetCurrentVideoFormat,CMockString_format);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_format), (void*)(format), sizeof(tvVideoHDRFormat_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetCurrentVideoFormat(CMOCK_GetCurrentVideoFormat_CALL_INSTANCE* cmock_call_instance, tvVideoHDRFormat_t* format);
void CMockExpectParameters_GetCurrentVideoFormat(CMOCK_GetCurrentVideoFormat_CALL_INSTANCE* cmock_call_instance, tvVideoHDRFormat_t* format)
{
  cmock_call_instance->Expected_format = format;
}

void GetCurrentVideoFormat_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvVideoHDRFormat_t* format, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetCurrentVideoFormat_CALL_INSTANCE));
  CMOCK_GetCurrentVideoFormat_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetCurrentVideoFormat_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetCurrentVideoFormat_CallInstance = CMock_Guts_MemChain(Mock.GetCurrentVideoFormat_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetCurrentVideoFormat(cmock_call_instance, format);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetVideoResolution(tvResolutionParam_t* res)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetVideoResolution_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetVideoResolution);
  cmock_call_instance = (CMOCK_GetVideoResolution_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetVideoResolution_CallInstance);
  Mock.GetVideoResolution_CallInstance = CMock_Guts_MemNext(Mock.GetVideoResolution_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetVideoResolution,CMockString_res);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_res), (void*)(res), sizeof(tvResolutionParam_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetVideoResolution(CMOCK_GetVideoResolution_CALL_INSTANCE* cmock_call_instance, tvResolutionParam_t* res);
void CMockExpectParameters_GetVideoResolution(CMOCK_GetVideoResolution_CALL_INSTANCE* cmock_call_instance, tvResolutionParam_t* res)
{
  cmock_call_instance->Expected_res = res;
}

void GetVideoResolution_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvResolutionParam_t* res, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetVideoResolution_CALL_INSTANCE));
  CMOCK_GetVideoResolution_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetVideoResolution_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetVideoResolution_CallInstance = CMock_Guts_MemChain(Mock.GetVideoResolution_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetVideoResolution(cmock_call_instance, res);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetVideoFrameRate(tvVideoFrameRate_t* format)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetVideoFrameRate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetVideoFrameRate);
  cmock_call_instance = (CMOCK_GetVideoFrameRate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetVideoFrameRate_CallInstance);
  Mock.GetVideoFrameRate_CallInstance = CMock_Guts_MemNext(Mock.GetVideoFrameRate_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetVideoFrameRate,CMockString_format);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_format), (void*)(format), sizeof(tvVideoFrameRate_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetVideoFrameRate(CMOCK_GetVideoFrameRate_CALL_INSTANCE* cmock_call_instance, tvVideoFrameRate_t* format);
void CMockExpectParameters_GetVideoFrameRate(CMOCK_GetVideoFrameRate_CALL_INSTANCE* cmock_call_instance, tvVideoFrameRate_t* format)
{
  cmock_call_instance->Expected_format = format;
}

void GetVideoFrameRate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvVideoFrameRate_t* format, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetVideoFrameRate_CALL_INSTANCE));
  CMOCK_GetVideoFrameRate_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetVideoFrameRate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetVideoFrameRate_CallInstance = CMock_Guts_MemChain(Mock.GetVideoFrameRate_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetVideoFrameRate(cmock_call_instance, format);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t setWakeupConfig(const tvWakeupSrcType_t src_type, const bool value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_setWakeupConfig_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_setWakeupConfig);
  cmock_call_instance = (CMOCK_setWakeupConfig_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.setWakeupConfig_CallInstance);
  Mock.setWakeupConfig_CallInstance = CMock_Guts_MemNext(Mock.setWakeupConfig_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_setWakeupConfig,CMockString_src_type);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_src_type), (void*)(&src_type), sizeof(tvWakeupSrcType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_setWakeupConfig,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_setWakeupConfig(CMOCK_setWakeupConfig_CALL_INSTANCE* cmock_call_instance, const tvWakeupSrcType_t src_type, const bool value);
void CMockExpectParameters_setWakeupConfig(CMOCK_setWakeupConfig_CALL_INSTANCE* cmock_call_instance, const tvWakeupSrcType_t src_type, const bool value)
{
  memcpy((void*)(&cmock_call_instance->Expected_src_type), (void*)(&src_type),
         sizeof(tvWakeupSrcType_t[sizeof(src_type) == sizeof(tvWakeupSrcType_t) ? 1 : -1])); /* add tvWakeupSrcType_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_value = value;
}

void setWakeupConfig_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const tvWakeupSrcType_t src_type, const bool value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_setWakeupConfig_CALL_INSTANCE));
  CMOCK_setWakeupConfig_CALL_INSTANCE* cmock_call_instance = (CMOCK_setWakeupConfig_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.setWakeupConfig_CallInstance = CMock_Guts_MemChain(Mock.setWakeupConfig_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_setWakeupConfig(cmock_call_instance, src_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetRGBPattern(int r, int g, int b)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetRGBPattern_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetRGBPattern);
  cmock_call_instance = (CMOCK_SetRGBPattern_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetRGBPattern_CallInstance);
  Mock.SetRGBPattern_CallInstance = CMock_Guts_MemNext(Mock.SetRGBPattern_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetRGBPattern,CMockString_r);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_r, r, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetRGBPattern,CMockString_g);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_g, g, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetRGBPattern,CMockString_b);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_b, b, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetRGBPattern(CMOCK_SetRGBPattern_CALL_INSTANCE* cmock_call_instance, int r, int g, int b);
void CMockExpectParameters_SetRGBPattern(CMOCK_SetRGBPattern_CALL_INSTANCE* cmock_call_instance, int r, int g, int b)
{
  cmock_call_instance->Expected_r = r;
  cmock_call_instance->Expected_g = g;
  cmock_call_instance->Expected_b = b;
}

void SetRGBPattern_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int r, int g, int b, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetRGBPattern_CALL_INSTANCE));
  CMOCK_SetRGBPattern_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetRGBPattern_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetRGBPattern_CallInstance = CMock_Guts_MemChain(Mock.SetRGBPattern_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetRGBPattern(cmock_call_instance, r, g, b);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetRGBPattern(int* r, int* g, int* b)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetRGBPattern_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetRGBPattern);
  cmock_call_instance = (CMOCK_GetRGBPattern_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetRGBPattern_CallInstance);
  Mock.GetRGBPattern_CallInstance = CMock_Guts_MemNext(Mock.GetRGBPattern_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetRGBPattern,CMockString_r);
    if (cmock_call_instance->Expected_r == NULL)
      { UNITY_TEST_ASSERT_NULL(r, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_r, r, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_GetRGBPattern,CMockString_g);
    if (cmock_call_instance->Expected_g == NULL)
      { UNITY_TEST_ASSERT_NULL(g, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_g, g, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_GetRGBPattern,CMockString_b);
    if (cmock_call_instance->Expected_b == NULL)
      { UNITY_TEST_ASSERT_NULL(b, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_b, b, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetRGBPattern(CMOCK_GetRGBPattern_CALL_INSTANCE* cmock_call_instance, int* r, int* g, int* b);
void CMockExpectParameters_GetRGBPattern(CMOCK_GetRGBPattern_CALL_INSTANCE* cmock_call_instance, int* r, int* g, int* b)
{
  cmock_call_instance->Expected_r = r;
  cmock_call_instance->Expected_g = g;
  cmock_call_instance->Expected_b = b;
}

void GetRGBPattern_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* r, int* g, int* b, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetRGBPattern_CALL_INSTANCE));
  CMOCK_GetRGBPattern_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetRGBPattern_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetRGBPattern_CallInstance = CMock_Guts_MemChain(Mock.GetRGBPattern_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetRGBPattern(cmock_call_instance, r, g, b);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetGrayPattern(int YUVValue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetGrayPattern_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetGrayPattern);
  cmock_call_instance = (CMOCK_SetGrayPattern_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetGrayPattern_CallInstance);
  Mock.SetGrayPattern_CallInstance = CMock_Guts_MemNext(Mock.SetGrayPattern_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetGrayPattern,CMockString_YUVValue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_YUVValue, YUVValue, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetGrayPattern(CMOCK_SetGrayPattern_CALL_INSTANCE* cmock_call_instance, int YUVValue);
void CMockExpectParameters_SetGrayPattern(CMOCK_SetGrayPattern_CALL_INSTANCE* cmock_call_instance, int YUVValue)
{
  cmock_call_instance->Expected_YUVValue = YUVValue;
}

void SetGrayPattern_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int YUVValue, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetGrayPattern_CALL_INSTANCE));
  CMOCK_SetGrayPattern_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetGrayPattern_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetGrayPattern_CallInstance = CMock_Guts_MemChain(Mock.SetGrayPattern_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetGrayPattern(cmock_call_instance, YUVValue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetGrayPattern(int* YUVValue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetGrayPattern_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetGrayPattern);
  cmock_call_instance = (CMOCK_GetGrayPattern_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetGrayPattern_CallInstance);
  Mock.GetGrayPattern_CallInstance = CMock_Guts_MemNext(Mock.GetGrayPattern_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetGrayPattern,CMockString_YUVValue);
    if (cmock_call_instance->Expected_YUVValue == NULL)
      { UNITY_TEST_ASSERT_NULL(YUVValue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_YUVValue, YUVValue, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetGrayPattern(CMOCK_GetGrayPattern_CALL_INSTANCE* cmock_call_instance, int* YUVValue);
void CMockExpectParameters_GetGrayPattern(CMOCK_GetGrayPattern_CALL_INSTANCE* cmock_call_instance, int* YUVValue)
{
  cmock_call_instance->Expected_YUVValue = YUVValue;
}

void GetGrayPattern_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* YUVValue, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetGrayPattern_CALL_INSTANCE));
  CMOCK_GetGrayPattern_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetGrayPattern_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetGrayPattern_CallInstance = CMock_Guts_MemChain(Mock.GetGrayPattern_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetGrayPattern(cmock_call_instance, YUVValue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemp_Rgain(tvColorTemp_t colorTemp, int rgain)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemp_Rgain_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemp_Rgain);
  cmock_call_instance = (CMOCK_SetColorTemp_Rgain_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemp_Rgain_CallInstance);
  Mock.SetColorTemp_Rgain_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemp_Rgain_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Rgain,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Rgain,CMockString_rgain);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_rgain, rgain, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemp_Rgain(CMOCK_SetColorTemp_Rgain_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int rgain);
void CMockExpectParameters_SetColorTemp_Rgain(CMOCK_SetColorTemp_Rgain_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int rgain)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_rgain = rgain;
}

void SetColorTemp_Rgain_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int rgain, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemp_Rgain_CALL_INSTANCE));
  CMOCK_SetColorTemp_Rgain_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemp_Rgain_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemp_Rgain_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemp_Rgain_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemp_Rgain(cmock_call_instance, colorTemp, rgain);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemp_Rgain(tvColorTemp_t colorTemp, int* rgain)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemp_Rgain_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemp_Rgain);
  cmock_call_instance = (CMOCK_GetColorTemp_Rgain_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemp_Rgain_CallInstance);
  Mock.GetColorTemp_Rgain_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemp_Rgain_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Rgain,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Rgain,CMockString_rgain);
    if (cmock_call_instance->Expected_rgain == NULL)
      { UNITY_TEST_ASSERT_NULL(rgain, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_rgain, rgain, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemp_Rgain(CMOCK_GetColorTemp_Rgain_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* rgain);
void CMockExpectParameters_GetColorTemp_Rgain(CMOCK_GetColorTemp_Rgain_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* rgain)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_rgain = rgain;
}

void GetColorTemp_Rgain_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int* rgain, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemp_Rgain_CALL_INSTANCE));
  CMOCK_GetColorTemp_Rgain_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemp_Rgain_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemp_Rgain_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemp_Rgain_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemp_Rgain(cmock_call_instance, colorTemp, rgain);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemp_Ggain(tvColorTemp_t colorTemp, int ggain)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemp_Ggain_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemp_Ggain);
  cmock_call_instance = (CMOCK_SetColorTemp_Ggain_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemp_Ggain_CallInstance);
  Mock.SetColorTemp_Ggain_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemp_Ggain_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Ggain,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Ggain,CMockString_ggain);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_ggain, ggain, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemp_Ggain(CMOCK_SetColorTemp_Ggain_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int ggain);
void CMockExpectParameters_SetColorTemp_Ggain(CMOCK_SetColorTemp_Ggain_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int ggain)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ggain = ggain;
}

void SetColorTemp_Ggain_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int ggain, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemp_Ggain_CALL_INSTANCE));
  CMOCK_SetColorTemp_Ggain_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemp_Ggain_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemp_Ggain_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemp_Ggain_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemp_Ggain(cmock_call_instance, colorTemp, ggain);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemp_Ggain(tvColorTemp_t colorTemp, int* ggain)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemp_Ggain_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemp_Ggain);
  cmock_call_instance = (CMOCK_GetColorTemp_Ggain_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemp_Ggain_CallInstance);
  Mock.GetColorTemp_Ggain_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemp_Ggain_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Ggain,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Ggain,CMockString_ggain);
    if (cmock_call_instance->Expected_ggain == NULL)
      { UNITY_TEST_ASSERT_NULL(ggain, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_ggain, ggain, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemp_Ggain(CMOCK_GetColorTemp_Ggain_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* ggain);
void CMockExpectParameters_GetColorTemp_Ggain(CMOCK_GetColorTemp_Ggain_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* ggain)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ggain = ggain;
}

void GetColorTemp_Ggain_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int* ggain, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemp_Ggain_CALL_INSTANCE));
  CMOCK_GetColorTemp_Ggain_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemp_Ggain_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemp_Ggain_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemp_Ggain_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemp_Ggain(cmock_call_instance, colorTemp, ggain);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemp_Bgain(tvColorTemp_t colorTemp, int bgain)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemp_Bgain_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemp_Bgain);
  cmock_call_instance = (CMOCK_SetColorTemp_Bgain_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemp_Bgain_CallInstance);
  Mock.SetColorTemp_Bgain_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemp_Bgain_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Bgain,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Bgain,CMockString_bgain);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_bgain, bgain, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemp_Bgain(CMOCK_SetColorTemp_Bgain_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int bgain);
void CMockExpectParameters_SetColorTemp_Bgain(CMOCK_SetColorTemp_Bgain_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int bgain)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_bgain = bgain;
}

void SetColorTemp_Bgain_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int bgain, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemp_Bgain_CALL_INSTANCE));
  CMOCK_SetColorTemp_Bgain_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemp_Bgain_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemp_Bgain_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemp_Bgain_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemp_Bgain(cmock_call_instance, colorTemp, bgain);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemp_Bgain(tvColorTemp_t colorTemp, int* bgain)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemp_Bgain_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemp_Bgain);
  cmock_call_instance = (CMOCK_GetColorTemp_Bgain_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemp_Bgain_CallInstance);
  Mock.GetColorTemp_Bgain_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemp_Bgain_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Bgain,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Bgain,CMockString_bgain);
    if (cmock_call_instance->Expected_bgain == NULL)
      { UNITY_TEST_ASSERT_NULL(bgain, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_bgain, bgain, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemp_Bgain(CMOCK_GetColorTemp_Bgain_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* bgain);
void CMockExpectParameters_GetColorTemp_Bgain(CMOCK_GetColorTemp_Bgain_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* bgain)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_bgain = bgain;
}

void GetColorTemp_Bgain_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int* bgain, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemp_Bgain_CALL_INSTANCE));
  CMOCK_GetColorTemp_Bgain_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemp_Bgain_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemp_Bgain_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemp_Bgain_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemp_Bgain(cmock_call_instance, colorTemp, bgain);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemp_R_post_offset(tvColorTemp_t colorTemp, int rpostoffset)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemp_R_post_offset_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemp_R_post_offset);
  cmock_call_instance = (CMOCK_SetColorTemp_R_post_offset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemp_R_post_offset_CallInstance);
  Mock.SetColorTemp_R_post_offset_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemp_R_post_offset_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_R_post_offset,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_R_post_offset,CMockString_rpostoffset);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_rpostoffset, rpostoffset, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemp_R_post_offset(CMOCK_SetColorTemp_R_post_offset_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int rpostoffset);
void CMockExpectParameters_SetColorTemp_R_post_offset(CMOCK_SetColorTemp_R_post_offset_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int rpostoffset)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_rpostoffset = rpostoffset;
}

void SetColorTemp_R_post_offset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int rpostoffset, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemp_R_post_offset_CALL_INSTANCE));
  CMOCK_SetColorTemp_R_post_offset_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemp_R_post_offset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemp_R_post_offset_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemp_R_post_offset_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemp_R_post_offset(cmock_call_instance, colorTemp, rpostoffset);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemp_R_post_offset(tvColorTemp_t colorTemp, int* rpostoffset)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemp_R_post_offset_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemp_R_post_offset);
  cmock_call_instance = (CMOCK_GetColorTemp_R_post_offset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemp_R_post_offset_CallInstance);
  Mock.GetColorTemp_R_post_offset_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemp_R_post_offset_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_R_post_offset,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_R_post_offset,CMockString_rpostoffset);
    if (cmock_call_instance->Expected_rpostoffset == NULL)
      { UNITY_TEST_ASSERT_NULL(rpostoffset, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_rpostoffset, rpostoffset, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemp_R_post_offset(CMOCK_GetColorTemp_R_post_offset_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* rpostoffset);
void CMockExpectParameters_GetColorTemp_R_post_offset(CMOCK_GetColorTemp_R_post_offset_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* rpostoffset)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_rpostoffset = rpostoffset;
}

void GetColorTemp_R_post_offset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int* rpostoffset, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemp_R_post_offset_CALL_INSTANCE));
  CMOCK_GetColorTemp_R_post_offset_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemp_R_post_offset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemp_R_post_offset_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemp_R_post_offset_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemp_R_post_offset(cmock_call_instance, colorTemp, rpostoffset);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemp_G_post_offset(tvColorTemp_t colorTemp, int gpostoffset)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemp_G_post_offset_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemp_G_post_offset);
  cmock_call_instance = (CMOCK_SetColorTemp_G_post_offset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemp_G_post_offset_CallInstance);
  Mock.SetColorTemp_G_post_offset_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemp_G_post_offset_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_G_post_offset,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_G_post_offset,CMockString_gpostoffset);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_gpostoffset, gpostoffset, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemp_G_post_offset(CMOCK_SetColorTemp_G_post_offset_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int gpostoffset);
void CMockExpectParameters_SetColorTemp_G_post_offset(CMOCK_SetColorTemp_G_post_offset_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int gpostoffset)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_gpostoffset = gpostoffset;
}

void SetColorTemp_G_post_offset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int gpostoffset, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemp_G_post_offset_CALL_INSTANCE));
  CMOCK_SetColorTemp_G_post_offset_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemp_G_post_offset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemp_G_post_offset_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemp_G_post_offset_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemp_G_post_offset(cmock_call_instance, colorTemp, gpostoffset);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemp_G_post_offset(tvColorTemp_t colorTemp, int* gpostoffset)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemp_G_post_offset_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemp_G_post_offset);
  cmock_call_instance = (CMOCK_GetColorTemp_G_post_offset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemp_G_post_offset_CallInstance);
  Mock.GetColorTemp_G_post_offset_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemp_G_post_offset_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_G_post_offset,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_G_post_offset,CMockString_gpostoffset);
    if (cmock_call_instance->Expected_gpostoffset == NULL)
      { UNITY_TEST_ASSERT_NULL(gpostoffset, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_gpostoffset, gpostoffset, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemp_G_post_offset(CMOCK_GetColorTemp_G_post_offset_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* gpostoffset);
void CMockExpectParameters_GetColorTemp_G_post_offset(CMOCK_GetColorTemp_G_post_offset_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* gpostoffset)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_gpostoffset = gpostoffset;
}

void GetColorTemp_G_post_offset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int* gpostoffset, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemp_G_post_offset_CALL_INSTANCE));
  CMOCK_GetColorTemp_G_post_offset_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemp_G_post_offset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemp_G_post_offset_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemp_G_post_offset_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemp_G_post_offset(cmock_call_instance, colorTemp, gpostoffset);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemp_B_post_offset(tvColorTemp_t colorTemp, int bpostoffset)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemp_B_post_offset_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemp_B_post_offset);
  cmock_call_instance = (CMOCK_SetColorTemp_B_post_offset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemp_B_post_offset_CallInstance);
  Mock.SetColorTemp_B_post_offset_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemp_B_post_offset_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_B_post_offset,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_B_post_offset,CMockString_bpostoffset);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_bpostoffset, bpostoffset, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemp_B_post_offset(CMOCK_SetColorTemp_B_post_offset_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int bpostoffset);
void CMockExpectParameters_SetColorTemp_B_post_offset(CMOCK_SetColorTemp_B_post_offset_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int bpostoffset)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_bpostoffset = bpostoffset;
}

void SetColorTemp_B_post_offset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int bpostoffset, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemp_B_post_offset_CALL_INSTANCE));
  CMOCK_SetColorTemp_B_post_offset_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemp_B_post_offset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemp_B_post_offset_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemp_B_post_offset_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemp_B_post_offset(cmock_call_instance, colorTemp, bpostoffset);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemp_B_post_offset(tvColorTemp_t colorTemp, int* bpostoffset)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemp_B_post_offset_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemp_B_post_offset);
  cmock_call_instance = (CMOCK_GetColorTemp_B_post_offset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemp_B_post_offset_CallInstance);
  Mock.GetColorTemp_B_post_offset_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemp_B_post_offset_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_B_post_offset,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_B_post_offset,CMockString_bpostoffset);
    if (cmock_call_instance->Expected_bpostoffset == NULL)
      { UNITY_TEST_ASSERT_NULL(bpostoffset, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_bpostoffset, bpostoffset, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemp_B_post_offset(CMOCK_GetColorTemp_B_post_offset_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* bpostoffset);
void CMockExpectParameters_GetColorTemp_B_post_offset(CMOCK_GetColorTemp_B_post_offset_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* bpostoffset)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_bpostoffset = bpostoffset;
}

void GetColorTemp_B_post_offset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int* bpostoffset, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemp_B_post_offset_CALL_INSTANCE));
  CMOCK_GetColorTemp_B_post_offset_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemp_B_post_offset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemp_B_post_offset_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemp_B_post_offset_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemp_B_post_offset(cmock_call_instance, colorTemp, bpostoffset);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetTVSupportedPictureModes(pic_modes_t** pictureModes, unsigned short* count)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetTVSupportedPictureModes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetTVSupportedPictureModes);
  cmock_call_instance = (CMOCK_GetTVSupportedPictureModes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetTVSupportedPictureModes_CallInstance);
  Mock.GetTVSupportedPictureModes_CallInstance = CMock_Guts_MemNext(Mock.GetTVSupportedPictureModes_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetTVSupportedPictureModes,CMockString_pictureModes);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pictureModes, pictureModes, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetTVSupportedPictureModes,CMockString_count);
    if (cmock_call_instance->Expected_count == NULL)
      { UNITY_TEST_ASSERT_NULL(count, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_count, count, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetTVSupportedPictureModes(CMOCK_GetTVSupportedPictureModes_CALL_INSTANCE* cmock_call_instance, pic_modes_t** pictureModes, unsigned short* count);
void CMockExpectParameters_GetTVSupportedPictureModes(CMOCK_GetTVSupportedPictureModes_CALL_INSTANCE* cmock_call_instance, pic_modes_t** pictureModes, unsigned short* count)
{
  cmock_call_instance->Expected_pictureModes = pictureModes;
  cmock_call_instance->Expected_count = count;
}

void GetTVSupportedPictureModes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, pic_modes_t** pictureModes, unsigned short* count, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetTVSupportedPictureModes_CALL_INSTANCE));
  CMOCK_GetTVSupportedPictureModes_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetTVSupportedPictureModes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetTVSupportedPictureModes_CallInstance = CMock_Guts_MemChain(Mock.GetTVSupportedPictureModes_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetTVSupportedPictureModes(cmock_call_instance, pictureModes, count);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetTVSupportedDVModes(pic_modes_t** dvModes, unsigned short* count)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetTVSupportedDVModes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetTVSupportedDVModes);
  cmock_call_instance = (CMOCK_GetTVSupportedDVModes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetTVSupportedDVModes_CallInstance);
  Mock.GetTVSupportedDVModes_CallInstance = CMock_Guts_MemNext(Mock.GetTVSupportedDVModes_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetTVSupportedDVModes,CMockString_dvModes);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_dvModes, dvModes, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetTVSupportedDVModes,CMockString_count);
    if (cmock_call_instance->Expected_count == NULL)
      { UNITY_TEST_ASSERT_NULL(count, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_count, count, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetTVSupportedDVModes(CMOCK_GetTVSupportedDVModes_CALL_INSTANCE* cmock_call_instance, pic_modes_t** dvModes, unsigned short* count);
void CMockExpectParameters_GetTVSupportedDVModes(CMOCK_GetTVSupportedDVModes_CALL_INSTANCE* cmock_call_instance, pic_modes_t** dvModes, unsigned short* count)
{
  cmock_call_instance->Expected_dvModes = dvModes;
  cmock_call_instance->Expected_count = count;
}

void GetTVSupportedDVModes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, pic_modes_t** dvModes, unsigned short* count, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetTVSupportedDVModes_CALL_INSTANCE));
  CMOCK_GetTVSupportedDVModes_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetTVSupportedDVModes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetTVSupportedDVModes_CallInstance = CMock_Guts_MemChain(Mock.GetTVSupportedDVModes_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetTVSupportedDVModes(cmock_call_instance, dvModes, count);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetTVDolbyVisionMode(const char* dolbyMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetTVDolbyVisionMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetTVDolbyVisionMode);
  cmock_call_instance = (CMOCK_SetTVDolbyVisionMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetTVDolbyVisionMode_CallInstance);
  Mock.SetTVDolbyVisionMode_CallInstance = CMock_Guts_MemNext(Mock.SetTVDolbyVisionMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetTVDolbyVisionMode,CMockString_dolbyMode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_dolbyMode, dolbyMode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetTVDolbyVisionMode(CMOCK_SetTVDolbyVisionMode_CALL_INSTANCE* cmock_call_instance, const char* dolbyMode);
void CMockExpectParameters_SetTVDolbyVisionMode(CMOCK_SetTVDolbyVisionMode_CALL_INSTANCE* cmock_call_instance, const char* dolbyMode)
{
  cmock_call_instance->Expected_dolbyMode = dolbyMode;
}

void SetTVDolbyVisionMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* dolbyMode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetTVDolbyVisionMode_CALL_INSTANCE));
  CMOCK_SetTVDolbyVisionMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetTVDolbyVisionMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetTVDolbyVisionMode_CallInstance = CMock_Guts_MemChain(Mock.SetTVDolbyVisionMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetTVDolbyVisionMode(cmock_call_instance, dolbyMode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetTVDolbyVisionMode(char* dolbyMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetTVDolbyVisionMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetTVDolbyVisionMode);
  cmock_call_instance = (CMOCK_GetTVDolbyVisionMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetTVDolbyVisionMode_CallInstance);
  Mock.GetTVDolbyVisionMode_CallInstance = CMock_Guts_MemNext(Mock.GetTVDolbyVisionMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetTVDolbyVisionMode,CMockString_dolbyMode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_dolbyMode, dolbyMode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetTVDolbyVisionMode(CMOCK_GetTVDolbyVisionMode_CALL_INSTANCE* cmock_call_instance, char* dolbyMode);
void CMockExpectParameters_GetTVDolbyVisionMode(CMOCK_GetTVDolbyVisionMode_CALL_INSTANCE* cmock_call_instance, char* dolbyMode)
{
  cmock_call_instance->Expected_dolbyMode = dolbyMode;
}

void GetTVDolbyVisionMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* dolbyMode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetTVDolbyVisionMode_CALL_INSTANCE));
  CMOCK_GetTVDolbyVisionMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetTVDolbyVisionMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetTVDolbyVisionMode_CallInstance = CMock_Guts_MemChain(Mock.GetTVDolbyVisionMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetTVDolbyVisionMode(cmock_call_instance, dolbyMode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetTVHLGMode(const char* hlgMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetTVHLGMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetTVHLGMode);
  cmock_call_instance = (CMOCK_SetTVHLGMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetTVHLGMode_CallInstance);
  Mock.SetTVHLGMode_CallInstance = CMock_Guts_MemNext(Mock.SetTVHLGMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetTVHLGMode,CMockString_hlgMode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_hlgMode, hlgMode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetTVHLGMode(CMOCK_SetTVHLGMode_CALL_INSTANCE* cmock_call_instance, const char* hlgMode);
void CMockExpectParameters_SetTVHLGMode(CMOCK_SetTVHLGMode_CALL_INSTANCE* cmock_call_instance, const char* hlgMode)
{
  cmock_call_instance->Expected_hlgMode = hlgMode;
}

void SetTVHLGMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* hlgMode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetTVHLGMode_CALL_INSTANCE));
  CMOCK_SetTVHLGMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetTVHLGMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetTVHLGMode_CallInstance = CMock_Guts_MemChain(Mock.SetTVHLGMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetTVHLGMode(cmock_call_instance, hlgMode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetTVHDR10Mode(const char* hdr10Mode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetTVHDR10Mode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetTVHDR10Mode);
  cmock_call_instance = (CMOCK_SetTVHDR10Mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetTVHDR10Mode_CallInstance);
  Mock.SetTVHDR10Mode_CallInstance = CMock_Guts_MemNext(Mock.SetTVHDR10Mode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetTVHDR10Mode,CMockString_hdr10Mode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_hdr10Mode, hdr10Mode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetTVHDR10Mode(CMOCK_SetTVHDR10Mode_CALL_INSTANCE* cmock_call_instance, const char* hdr10Mode);
void CMockExpectParameters_SetTVHDR10Mode(CMOCK_SetTVHDR10Mode_CALL_INSTANCE* cmock_call_instance, const char* hdr10Mode)
{
  cmock_call_instance->Expected_hdr10Mode = hdr10Mode;
}

void SetTVHDR10Mode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* hdr10Mode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetTVHDR10Mode_CALL_INSTANCE));
  CMOCK_SetTVHDR10Mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetTVHDR10Mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetTVHDR10Mode_CallInstance = CMock_Guts_MemChain(Mock.SetTVHDR10Mode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetTVHDR10Mode(cmock_call_instance, hdr10Mode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetTVHLGMode(char* hlgMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetTVHLGMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetTVHLGMode);
  cmock_call_instance = (CMOCK_GetTVHLGMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetTVHLGMode_CallInstance);
  Mock.GetTVHLGMode_CallInstance = CMock_Guts_MemNext(Mock.GetTVHLGMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetTVHLGMode,CMockString_hlgMode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_hlgMode, hlgMode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetTVHLGMode(CMOCK_GetTVHLGMode_CALL_INSTANCE* cmock_call_instance, char* hlgMode);
void CMockExpectParameters_GetTVHLGMode(CMOCK_GetTVHLGMode_CALL_INSTANCE* cmock_call_instance, char* hlgMode)
{
  cmock_call_instance->Expected_hlgMode = hlgMode;
}

void GetTVHLGMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* hlgMode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetTVHLGMode_CALL_INSTANCE));
  CMOCK_GetTVHLGMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetTVHLGMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetTVHLGMode_CallInstance = CMock_Guts_MemChain(Mock.GetTVHLGMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetTVHLGMode(cmock_call_instance, hlgMode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetTVHDR10Mode(char* hdr10Mode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetTVHDR10Mode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetTVHDR10Mode);
  cmock_call_instance = (CMOCK_GetTVHDR10Mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetTVHDR10Mode_CallInstance);
  Mock.GetTVHDR10Mode_CallInstance = CMock_Guts_MemNext(Mock.GetTVHDR10Mode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetTVHDR10Mode,CMockString_hdr10Mode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_hdr10Mode, hdr10Mode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetTVHDR10Mode(CMOCK_GetTVHDR10Mode_CALL_INSTANCE* cmock_call_instance, char* hdr10Mode);
void CMockExpectParameters_GetTVHDR10Mode(CMOCK_GetTVHDR10Mode_CALL_INSTANCE* cmock_call_instance, char* hdr10Mode)
{
  cmock_call_instance->Expected_hdr10Mode = hdr10Mode;
}

void GetTVHDR10Mode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* hdr10Mode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetTVHDR10Mode_CALL_INSTANCE));
  CMOCK_GetTVHDR10Mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetTVHDR10Mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetTVHDR10Mode_CallInstance = CMock_Guts_MemChain(Mock.GetTVHDR10Mode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetTVHDR10Mode(cmock_call_instance, hdr10Mode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetTVSupportedHLGModes(pic_modes_t** dvModes, unsigned short* count)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetTVSupportedHLGModes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetTVSupportedHLGModes);
  cmock_call_instance = (CMOCK_GetTVSupportedHLGModes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetTVSupportedHLGModes_CallInstance);
  Mock.GetTVSupportedHLGModes_CallInstance = CMock_Guts_MemNext(Mock.GetTVSupportedHLGModes_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetTVSupportedHLGModes,CMockString_dvModes);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_dvModes, dvModes, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetTVSupportedHLGModes,CMockString_count);
    if (cmock_call_instance->Expected_count == NULL)
      { UNITY_TEST_ASSERT_NULL(count, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_count, count, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetTVSupportedHLGModes(CMOCK_GetTVSupportedHLGModes_CALL_INSTANCE* cmock_call_instance, pic_modes_t** dvModes, unsigned short* count);
void CMockExpectParameters_GetTVSupportedHLGModes(CMOCK_GetTVSupportedHLGModes_CALL_INSTANCE* cmock_call_instance, pic_modes_t** dvModes, unsigned short* count)
{
  cmock_call_instance->Expected_dvModes = dvModes;
  cmock_call_instance->Expected_count = count;
}

void GetTVSupportedHLGModes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, pic_modes_t** dvModes, unsigned short* count, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetTVSupportedHLGModes_CALL_INSTANCE));
  CMOCK_GetTVSupportedHLGModes_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetTVSupportedHLGModes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetTVSupportedHLGModes_CallInstance = CMock_Guts_MemChain(Mock.GetTVSupportedHLGModes_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetTVSupportedHLGModes(cmock_call_instance, dvModes, count);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetTVSupportedHDR10Modes(pic_modes_t** dvModes, unsigned short* count)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetTVSupportedHDR10Modes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetTVSupportedHDR10Modes);
  cmock_call_instance = (CMOCK_GetTVSupportedHDR10Modes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetTVSupportedHDR10Modes_CallInstance);
  Mock.GetTVSupportedHDR10Modes_CallInstance = CMock_Guts_MemNext(Mock.GetTVSupportedHDR10Modes_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetTVSupportedHDR10Modes,CMockString_dvModes);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_dvModes, dvModes, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetTVSupportedHDR10Modes,CMockString_count);
    if (cmock_call_instance->Expected_count == NULL)
      { UNITY_TEST_ASSERT_NULL(count, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_count, count, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetTVSupportedHDR10Modes(CMOCK_GetTVSupportedHDR10Modes_CALL_INSTANCE* cmock_call_instance, pic_modes_t** dvModes, unsigned short* count);
void CMockExpectParameters_GetTVSupportedHDR10Modes(CMOCK_GetTVSupportedHDR10Modes_CALL_INSTANCE* cmock_call_instance, pic_modes_t** dvModes, unsigned short* count)
{
  cmock_call_instance->Expected_dvModes = dvModes;
  cmock_call_instance->Expected_count = count;
}

void GetTVSupportedHDR10Modes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, pic_modes_t** dvModes, unsigned short* count, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetTVSupportedHDR10Modes_CALL_INSTANCE));
  CMOCK_GetTVSupportedHDR10Modes_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetTVSupportedHDR10Modes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetTVSupportedHDR10Modes_CallInstance = CMock_Guts_MemChain(Mock.GetTVSupportedHDR10Modes_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetTVSupportedHDR10Modes(cmock_call_instance, dvModes, count);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetDynamicContrast(const char* dynamicContrastEnable)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetDynamicContrast_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetDynamicContrast);
  cmock_call_instance = (CMOCK_SetDynamicContrast_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetDynamicContrast_CallInstance);
  Mock.SetDynamicContrast_CallInstance = CMock_Guts_MemNext(Mock.SetDynamicContrast_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetDynamicContrast,CMockString_dynamicContrastEnable);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_dynamicContrastEnable, dynamicContrastEnable, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetDynamicContrast(CMOCK_SetDynamicContrast_CALL_INSTANCE* cmock_call_instance, const char* dynamicContrastEnable);
void CMockExpectParameters_SetDynamicContrast(CMOCK_SetDynamicContrast_CALL_INSTANCE* cmock_call_instance, const char* dynamicContrastEnable)
{
  cmock_call_instance->Expected_dynamicContrastEnable = dynamicContrastEnable;
}

void SetDynamicContrast_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* dynamicContrastEnable, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetDynamicContrast_CALL_INSTANCE));
  CMOCK_SetDynamicContrast_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetDynamicContrast_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetDynamicContrast_CallInstance = CMock_Guts_MemChain(Mock.SetDynamicContrast_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetDynamicContrast(cmock_call_instance, dynamicContrastEnable);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetDynamicContrast(char* isDynamicContrastEnabled)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetDynamicContrast_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetDynamicContrast);
  cmock_call_instance = (CMOCK_GetDynamicContrast_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetDynamicContrast_CallInstance);
  Mock.GetDynamicContrast_CallInstance = CMock_Guts_MemNext(Mock.GetDynamicContrast_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetDynamicContrast,CMockString_isDynamicContrastEnabled);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_isDynamicContrastEnabled, isDynamicContrastEnabled, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetDynamicContrast(CMOCK_GetDynamicContrast_CALL_INSTANCE* cmock_call_instance, char* isDynamicContrastEnabled);
void CMockExpectParameters_GetDynamicContrast(CMOCK_GetDynamicContrast_CALL_INSTANCE* cmock_call_instance, char* isDynamicContrastEnabled)
{
  cmock_call_instance->Expected_isDynamicContrastEnabled = isDynamicContrastEnabled;
}

void GetDynamicContrast_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* isDynamicContrastEnabled, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetDynamicContrast_CALL_INSTANCE));
  CMOCK_GetDynamicContrast_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetDynamicContrast_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetDynamicContrast_CallInstance = CMock_Guts_MemChain(Mock.GetDynamicContrast_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetDynamicContrast(cmock_call_instance, isDynamicContrastEnabled);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemp_Rgain_onSource(tvColorTemp_t colorTemp, int rgain, int sourceId, int saveOnly)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemp_Rgain_onSource_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemp_Rgain_onSource);
  cmock_call_instance = (CMOCK_SetColorTemp_Rgain_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemp_Rgain_onSource_CallInstance);
  Mock.SetColorTemp_Rgain_onSource_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemp_Rgain_onSource_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Rgain_onSource,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Rgain_onSource,CMockString_rgain);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_rgain, rgain, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Rgain_onSource,CMockString_sourceId);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceId, sourceId, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Rgain_onSource,CMockString_saveOnly);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_saveOnly, saveOnly, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemp_Rgain_onSource(CMOCK_SetColorTemp_Rgain_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int rgain, int sourceId, int saveOnly);
void CMockExpectParameters_SetColorTemp_Rgain_onSource(CMOCK_SetColorTemp_Rgain_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int rgain, int sourceId, int saveOnly)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_rgain = rgain;
  cmock_call_instance->Expected_sourceId = sourceId;
  cmock_call_instance->Expected_saveOnly = saveOnly;
}

void SetColorTemp_Rgain_onSource_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int rgain, int sourceId, int saveOnly, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemp_Rgain_onSource_CALL_INSTANCE));
  CMOCK_SetColorTemp_Rgain_onSource_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemp_Rgain_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemp_Rgain_onSource_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemp_Rgain_onSource_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemp_Rgain_onSource(cmock_call_instance, colorTemp, rgain, sourceId, saveOnly);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemp_Rgain_onSource(tvColorTemp_t colorTemp, int* rgain, int sourceId)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemp_Rgain_onSource_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemp_Rgain_onSource);
  cmock_call_instance = (CMOCK_GetColorTemp_Rgain_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemp_Rgain_onSource_CallInstance);
  Mock.GetColorTemp_Rgain_onSource_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemp_Rgain_onSource_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Rgain_onSource,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Rgain_onSource,CMockString_rgain);
    if (cmock_call_instance->Expected_rgain == NULL)
      { UNITY_TEST_ASSERT_NULL(rgain, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_rgain, rgain, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Rgain_onSource,CMockString_sourceId);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceId, sourceId, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemp_Rgain_onSource(CMOCK_GetColorTemp_Rgain_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* rgain, int sourceId);
void CMockExpectParameters_GetColorTemp_Rgain_onSource(CMOCK_GetColorTemp_Rgain_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* rgain, int sourceId)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_rgain = rgain;
  cmock_call_instance->Expected_sourceId = sourceId;
}

void GetColorTemp_Rgain_onSource_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int* rgain, int sourceId, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemp_Rgain_onSource_CALL_INSTANCE));
  CMOCK_GetColorTemp_Rgain_onSource_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemp_Rgain_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemp_Rgain_onSource_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemp_Rgain_onSource_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemp_Rgain_onSource(cmock_call_instance, colorTemp, rgain, sourceId);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemp_Ggain_onSource(tvColorTemp_t colorTemp, int ggain, int sourceId, int saveOnly)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemp_Ggain_onSource_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemp_Ggain_onSource);
  cmock_call_instance = (CMOCK_SetColorTemp_Ggain_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemp_Ggain_onSource_CallInstance);
  Mock.SetColorTemp_Ggain_onSource_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemp_Ggain_onSource_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Ggain_onSource,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Ggain_onSource,CMockString_ggain);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_ggain, ggain, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Ggain_onSource,CMockString_sourceId);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceId, sourceId, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Ggain_onSource,CMockString_saveOnly);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_saveOnly, saveOnly, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemp_Ggain_onSource(CMOCK_SetColorTemp_Ggain_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int ggain, int sourceId, int saveOnly);
void CMockExpectParameters_SetColorTemp_Ggain_onSource(CMOCK_SetColorTemp_Ggain_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int ggain, int sourceId, int saveOnly)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ggain = ggain;
  cmock_call_instance->Expected_sourceId = sourceId;
  cmock_call_instance->Expected_saveOnly = saveOnly;
}

void SetColorTemp_Ggain_onSource_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int ggain, int sourceId, int saveOnly, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemp_Ggain_onSource_CALL_INSTANCE));
  CMOCK_SetColorTemp_Ggain_onSource_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemp_Ggain_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemp_Ggain_onSource_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemp_Ggain_onSource_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemp_Ggain_onSource(cmock_call_instance, colorTemp, ggain, sourceId, saveOnly);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemp_Ggain_onSource(tvColorTemp_t colorTemp, int* ggain, int sourceId)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemp_Ggain_onSource_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemp_Ggain_onSource);
  cmock_call_instance = (CMOCK_GetColorTemp_Ggain_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemp_Ggain_onSource_CallInstance);
  Mock.GetColorTemp_Ggain_onSource_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemp_Ggain_onSource_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Ggain_onSource,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Ggain_onSource,CMockString_ggain);
    if (cmock_call_instance->Expected_ggain == NULL)
      { UNITY_TEST_ASSERT_NULL(ggain, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_ggain, ggain, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Ggain_onSource,CMockString_sourceId);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceId, sourceId, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemp_Ggain_onSource(CMOCK_GetColorTemp_Ggain_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* ggain, int sourceId);
void CMockExpectParameters_GetColorTemp_Ggain_onSource(CMOCK_GetColorTemp_Ggain_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* ggain, int sourceId)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ggain = ggain;
  cmock_call_instance->Expected_sourceId = sourceId;
}

void GetColorTemp_Ggain_onSource_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int* ggain, int sourceId, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemp_Ggain_onSource_CALL_INSTANCE));
  CMOCK_GetColorTemp_Ggain_onSource_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemp_Ggain_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemp_Ggain_onSource_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemp_Ggain_onSource_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemp_Ggain_onSource(cmock_call_instance, colorTemp, ggain, sourceId);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemp_Bgain_onSource(tvColorTemp_t colorTemp, int bgain, int sourceId, int saveOnly)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemp_Bgain_onSource_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemp_Bgain_onSource);
  cmock_call_instance = (CMOCK_SetColorTemp_Bgain_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemp_Bgain_onSource_CallInstance);
  Mock.SetColorTemp_Bgain_onSource_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemp_Bgain_onSource_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Bgain_onSource,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Bgain_onSource,CMockString_bgain);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_bgain, bgain, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Bgain_onSource,CMockString_sourceId);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceId, sourceId, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_Bgain_onSource,CMockString_saveOnly);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_saveOnly, saveOnly, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemp_Bgain_onSource(CMOCK_SetColorTemp_Bgain_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int bgain, int sourceId, int saveOnly);
void CMockExpectParameters_SetColorTemp_Bgain_onSource(CMOCK_SetColorTemp_Bgain_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int bgain, int sourceId, int saveOnly)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_bgain = bgain;
  cmock_call_instance->Expected_sourceId = sourceId;
  cmock_call_instance->Expected_saveOnly = saveOnly;
}

void SetColorTemp_Bgain_onSource_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int bgain, int sourceId, int saveOnly, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemp_Bgain_onSource_CALL_INSTANCE));
  CMOCK_SetColorTemp_Bgain_onSource_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemp_Bgain_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemp_Bgain_onSource_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemp_Bgain_onSource_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemp_Bgain_onSource(cmock_call_instance, colorTemp, bgain, sourceId, saveOnly);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemp_Bgain_onSource(tvColorTemp_t colorTemp, int* bgain, int sourceId)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemp_Bgain_onSource_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemp_Bgain_onSource);
  cmock_call_instance = (CMOCK_GetColorTemp_Bgain_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemp_Bgain_onSource_CallInstance);
  Mock.GetColorTemp_Bgain_onSource_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemp_Bgain_onSource_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Bgain_onSource,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Bgain_onSource,CMockString_bgain);
    if (cmock_call_instance->Expected_bgain == NULL)
      { UNITY_TEST_ASSERT_NULL(bgain, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_bgain, bgain, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_Bgain_onSource,CMockString_sourceId);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceId, sourceId, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemp_Bgain_onSource(CMOCK_GetColorTemp_Bgain_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* bgain, int sourceId);
void CMockExpectParameters_GetColorTemp_Bgain_onSource(CMOCK_GetColorTemp_Bgain_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* bgain, int sourceId)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_bgain = bgain;
  cmock_call_instance->Expected_sourceId = sourceId;
}

void GetColorTemp_Bgain_onSource_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int* bgain, int sourceId, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemp_Bgain_onSource_CALL_INSTANCE));
  CMOCK_GetColorTemp_Bgain_onSource_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemp_Bgain_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemp_Bgain_onSource_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemp_Bgain_onSource_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemp_Bgain_onSource(cmock_call_instance, colorTemp, bgain, sourceId);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemp_R_post_offset_onSource(tvColorTemp_t colorTemp, int rpostoffset, int sourceId, int saveOnly)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemp_R_post_offset_onSource_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemp_R_post_offset_onSource);
  cmock_call_instance = (CMOCK_SetColorTemp_R_post_offset_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemp_R_post_offset_onSource_CallInstance);
  Mock.SetColorTemp_R_post_offset_onSource_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemp_R_post_offset_onSource_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_R_post_offset_onSource,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_R_post_offset_onSource,CMockString_rpostoffset);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_rpostoffset, rpostoffset, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_R_post_offset_onSource,CMockString_sourceId);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceId, sourceId, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_R_post_offset_onSource,CMockString_saveOnly);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_saveOnly, saveOnly, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemp_R_post_offset_onSource(CMOCK_SetColorTemp_R_post_offset_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int rpostoffset, int sourceId, int saveOnly);
void CMockExpectParameters_SetColorTemp_R_post_offset_onSource(CMOCK_SetColorTemp_R_post_offset_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int rpostoffset, int sourceId, int saveOnly)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_rpostoffset = rpostoffset;
  cmock_call_instance->Expected_sourceId = sourceId;
  cmock_call_instance->Expected_saveOnly = saveOnly;
}

void SetColorTemp_R_post_offset_onSource_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int rpostoffset, int sourceId, int saveOnly, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemp_R_post_offset_onSource_CALL_INSTANCE));
  CMOCK_SetColorTemp_R_post_offset_onSource_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemp_R_post_offset_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemp_R_post_offset_onSource_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemp_R_post_offset_onSource_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemp_R_post_offset_onSource(cmock_call_instance, colorTemp, rpostoffset, sourceId, saveOnly);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemp_R_post_offset_onSource(tvColorTemp_t colorTemp, int* rpostoffset, int sourceId)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemp_R_post_offset_onSource_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemp_R_post_offset_onSource);
  cmock_call_instance = (CMOCK_GetColorTemp_R_post_offset_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemp_R_post_offset_onSource_CallInstance);
  Mock.GetColorTemp_R_post_offset_onSource_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemp_R_post_offset_onSource_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_R_post_offset_onSource,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_R_post_offset_onSource,CMockString_rpostoffset);
    if (cmock_call_instance->Expected_rpostoffset == NULL)
      { UNITY_TEST_ASSERT_NULL(rpostoffset, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_rpostoffset, rpostoffset, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_R_post_offset_onSource,CMockString_sourceId);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceId, sourceId, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemp_R_post_offset_onSource(CMOCK_GetColorTemp_R_post_offset_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* rpostoffset, int sourceId);
void CMockExpectParameters_GetColorTemp_R_post_offset_onSource(CMOCK_GetColorTemp_R_post_offset_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* rpostoffset, int sourceId)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_rpostoffset = rpostoffset;
  cmock_call_instance->Expected_sourceId = sourceId;
}

void GetColorTemp_R_post_offset_onSource_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int* rpostoffset, int sourceId, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemp_R_post_offset_onSource_CALL_INSTANCE));
  CMOCK_GetColorTemp_R_post_offset_onSource_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemp_R_post_offset_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemp_R_post_offset_onSource_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemp_R_post_offset_onSource_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemp_R_post_offset_onSource(cmock_call_instance, colorTemp, rpostoffset, sourceId);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemp_G_post_offset_onSource(tvColorTemp_t colorTemp, int gpostoffset, int sourceId, int saveOnly)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemp_G_post_offset_onSource_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemp_G_post_offset_onSource);
  cmock_call_instance = (CMOCK_SetColorTemp_G_post_offset_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemp_G_post_offset_onSource_CallInstance);
  Mock.SetColorTemp_G_post_offset_onSource_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemp_G_post_offset_onSource_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_G_post_offset_onSource,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_G_post_offset_onSource,CMockString_gpostoffset);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_gpostoffset, gpostoffset, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_G_post_offset_onSource,CMockString_sourceId);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceId, sourceId, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_G_post_offset_onSource,CMockString_saveOnly);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_saveOnly, saveOnly, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemp_G_post_offset_onSource(CMOCK_SetColorTemp_G_post_offset_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int gpostoffset, int sourceId, int saveOnly);
void CMockExpectParameters_SetColorTemp_G_post_offset_onSource(CMOCK_SetColorTemp_G_post_offset_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int gpostoffset, int sourceId, int saveOnly)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_gpostoffset = gpostoffset;
  cmock_call_instance->Expected_sourceId = sourceId;
  cmock_call_instance->Expected_saveOnly = saveOnly;
}

void SetColorTemp_G_post_offset_onSource_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int gpostoffset, int sourceId, int saveOnly, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemp_G_post_offset_onSource_CALL_INSTANCE));
  CMOCK_SetColorTemp_G_post_offset_onSource_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemp_G_post_offset_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemp_G_post_offset_onSource_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemp_G_post_offset_onSource_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemp_G_post_offset_onSource(cmock_call_instance, colorTemp, gpostoffset, sourceId, saveOnly);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemp_G_post_offset_onSource(tvColorTemp_t colorTemp, int* gpostoffset, int sourceId)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemp_G_post_offset_onSource_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemp_G_post_offset_onSource);
  cmock_call_instance = (CMOCK_GetColorTemp_G_post_offset_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemp_G_post_offset_onSource_CallInstance);
  Mock.GetColorTemp_G_post_offset_onSource_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemp_G_post_offset_onSource_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_G_post_offset_onSource,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_G_post_offset_onSource,CMockString_gpostoffset);
    if (cmock_call_instance->Expected_gpostoffset == NULL)
      { UNITY_TEST_ASSERT_NULL(gpostoffset, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_gpostoffset, gpostoffset, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_G_post_offset_onSource,CMockString_sourceId);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceId, sourceId, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemp_G_post_offset_onSource(CMOCK_GetColorTemp_G_post_offset_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* gpostoffset, int sourceId);
void CMockExpectParameters_GetColorTemp_G_post_offset_onSource(CMOCK_GetColorTemp_G_post_offset_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* gpostoffset, int sourceId)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_gpostoffset = gpostoffset;
  cmock_call_instance->Expected_sourceId = sourceId;
}

void GetColorTemp_G_post_offset_onSource_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int* gpostoffset, int sourceId, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemp_G_post_offset_onSource_CALL_INSTANCE));
  CMOCK_GetColorTemp_G_post_offset_onSource_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemp_G_post_offset_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemp_G_post_offset_onSource_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemp_G_post_offset_onSource_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemp_G_post_offset_onSource(cmock_call_instance, colorTemp, gpostoffset, sourceId);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetColorTemp_B_post_offset_onSource(tvColorTemp_t colorTemp, int bpostoffset, int sourceId, int saveOnly)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemp_B_post_offset_onSource_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemp_B_post_offset_onSource);
  cmock_call_instance = (CMOCK_SetColorTemp_B_post_offset_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemp_B_post_offset_onSource_CallInstance);
  Mock.SetColorTemp_B_post_offset_onSource_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemp_B_post_offset_onSource_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_B_post_offset_onSource,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_B_post_offset_onSource,CMockString_bpostoffset);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_bpostoffset, bpostoffset, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_B_post_offset_onSource,CMockString_sourceId);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceId, sourceId, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemp_B_post_offset_onSource,CMockString_saveOnly);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_saveOnly, saveOnly, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemp_B_post_offset_onSource(CMOCK_SetColorTemp_B_post_offset_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int bpostoffset, int sourceId, int saveOnly);
void CMockExpectParameters_SetColorTemp_B_post_offset_onSource(CMOCK_SetColorTemp_B_post_offset_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int bpostoffset, int sourceId, int saveOnly)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_bpostoffset = bpostoffset;
  cmock_call_instance->Expected_sourceId = sourceId;
  cmock_call_instance->Expected_saveOnly = saveOnly;
}

void SetColorTemp_B_post_offset_onSource_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int bpostoffset, int sourceId, int saveOnly, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemp_B_post_offset_onSource_CALL_INSTANCE));
  CMOCK_SetColorTemp_B_post_offset_onSource_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemp_B_post_offset_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemp_B_post_offset_onSource_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemp_B_post_offset_onSource_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemp_B_post_offset_onSource(cmock_call_instance, colorTemp, bpostoffset, sourceId, saveOnly);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetColorTemp_B_post_offset_onSource(tvColorTemp_t colorTemp, int* bpostoffset, int sourceId)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetColorTemp_B_post_offset_onSource_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetColorTemp_B_post_offset_onSource);
  cmock_call_instance = (CMOCK_GetColorTemp_B_post_offset_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetColorTemp_B_post_offset_onSource_CallInstance);
  Mock.GetColorTemp_B_post_offset_onSource_CallInstance = CMock_Guts_MemNext(Mock.GetColorTemp_B_post_offset_onSource_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_B_post_offset_onSource,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp), sizeof(tvColorTemp_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_B_post_offset_onSource,CMockString_bpostoffset);
    if (cmock_call_instance->Expected_bpostoffset == NULL)
      { UNITY_TEST_ASSERT_NULL(bpostoffset, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_bpostoffset, bpostoffset, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_GetColorTemp_B_post_offset_onSource,CMockString_sourceId);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceId, sourceId, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetColorTemp_B_post_offset_onSource(CMOCK_GetColorTemp_B_post_offset_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* bpostoffset, int sourceId);
void CMockExpectParameters_GetColorTemp_B_post_offset_onSource(CMOCK_GetColorTemp_B_post_offset_onSource_CALL_INSTANCE* cmock_call_instance, tvColorTemp_t colorTemp, int* bpostoffset, int sourceId)
{
  memcpy((void*)(&cmock_call_instance->Expected_colorTemp), (void*)(&colorTemp),
         sizeof(tvColorTemp_t[sizeof(colorTemp) == sizeof(tvColorTemp_t) ? 1 : -1])); /* add tvColorTemp_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_bpostoffset = bpostoffset;
  cmock_call_instance->Expected_sourceId = sourceId;
}

void GetColorTemp_B_post_offset_onSource_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvColorTemp_t colorTemp, int* bpostoffset, int sourceId, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetColorTemp_B_post_offset_onSource_CALL_INSTANCE));
  CMOCK_GetColorTemp_B_post_offset_onSource_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetColorTemp_B_post_offset_onSource_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetColorTemp_B_post_offset_onSource_CallInstance = CMock_Guts_MemChain(Mock.GetColorTemp_B_post_offset_onSource_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetColorTemp_B_post_offset_onSource(cmock_call_instance, colorTemp, bpostoffset, sourceId);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t setWBctrl(char* inputSrc, char* colorTemp, char* color, char* ctrl, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_setWBctrl_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_setWBctrl);
  cmock_call_instance = (CMOCK_setWBctrl_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.setWBctrl_CallInstance);
  Mock.setWBctrl_CallInstance = CMock_Guts_MemNext(Mock.setWBctrl_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_setWBctrl,CMockString_inputSrc);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_inputSrc, inputSrc, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_setWBctrl,CMockString_colorTemp);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_colorTemp, colorTemp, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_setWBctrl,CMockString_color);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_color, color, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_setWBctrl,CMockString_ctrl);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_ctrl, ctrl, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_setWBctrl,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_setWBctrl(CMOCK_setWBctrl_CALL_INSTANCE* cmock_call_instance, char* inputSrc, char* colorTemp, char* color, char* ctrl, int value);
void CMockExpectParameters_setWBctrl(CMOCK_setWBctrl_CALL_INSTANCE* cmock_call_instance, char* inputSrc, char* colorTemp, char* color, char* ctrl, int value)
{
  cmock_call_instance->Expected_inputSrc = inputSrc;
  cmock_call_instance->Expected_colorTemp = colorTemp;
  cmock_call_instance->Expected_color = color;
  cmock_call_instance->Expected_ctrl = ctrl;
  cmock_call_instance->Expected_value = value;
}

void setWBctrl_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* inputSrc, char* colorTemp, char* color, char* ctrl, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_setWBctrl_CALL_INSTANCE));
  CMOCK_setWBctrl_CALL_INSTANCE* cmock_call_instance = (CMOCK_setWBctrl_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.setWBctrl_CallInstance = CMock_Guts_MemChain(Mock.setWBctrl_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_setWBctrl(cmock_call_instance, inputSrc, colorTemp, color, ctrl, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t getWBctrl(char* inputSrc, char* colortemp, char* color, char* ctrl, int* value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_getWBctrl_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_getWBctrl);
  cmock_call_instance = (CMOCK_getWBctrl_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.getWBctrl_CallInstance);
  Mock.getWBctrl_CallInstance = CMock_Guts_MemNext(Mock.getWBctrl_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_getWBctrl,CMockString_inputSrc);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_inputSrc, inputSrc, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_getWBctrl,CMockString_colortemp);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_colortemp, colortemp, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_getWBctrl,CMockString_color);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_color, color, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_getWBctrl,CMockString_ctrl);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_ctrl, ctrl, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_getWBctrl,CMockString_value);
    if (cmock_call_instance->Expected_value == NULL)
      { UNITY_TEST_ASSERT_NULL(value, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_value, value, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_getWBctrl(CMOCK_getWBctrl_CALL_INSTANCE* cmock_call_instance, char* inputSrc, char* colortemp, char* color, char* ctrl, int* value);
void CMockExpectParameters_getWBctrl(CMOCK_getWBctrl_CALL_INSTANCE* cmock_call_instance, char* inputSrc, char* colortemp, char* color, char* ctrl, int* value)
{
  cmock_call_instance->Expected_inputSrc = inputSrc;
  cmock_call_instance->Expected_colortemp = colortemp;
  cmock_call_instance->Expected_color = color;
  cmock_call_instance->Expected_ctrl = ctrl;
  cmock_call_instance->Expected_value = value;
}

void getWBctrl_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* inputSrc, char* colortemp, char* color, char* ctrl, int* value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_getWBctrl_CALL_INSTANCE));
  CMOCK_getWBctrl_CALL_INSTANCE* cmock_call_instance = (CMOCK_getWBctrl_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.getWBctrl_CallInstance = CMock_Guts_MemChain(Mock.getWBctrl_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_getWBctrl(cmock_call_instance, inputSrc, colortemp, color, ctrl, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t enableWBmode(bool value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_enableWBmode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_enableWBmode);
  cmock_call_instance = (CMOCK_enableWBmode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.enableWBmode_CallInstance);
  Mock.enableWBmode_CallInstance = CMock_Guts_MemNext(Mock.enableWBmode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_enableWBmode,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_enableWBmode(CMOCK_enableWBmode_CALL_INSTANCE* cmock_call_instance, bool value);
void CMockExpectParameters_enableWBmode(CMOCK_enableWBmode_CALL_INSTANCE* cmock_call_instance, bool value)
{
  cmock_call_instance->Expected_value = value;
}

void enableWBmode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, bool value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_enableWBmode_CALL_INSTANCE));
  CMOCK_enableWBmode_CALL_INSTANCE* cmock_call_instance = (CMOCK_enableWBmode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.enableWBmode_CallInstance = CMock_Guts_MemChain(Mock.enableWBmode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_enableWBmode(cmock_call_instance, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetSupportedComponentColor(int* blComponentColor)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetSupportedComponentColor_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetSupportedComponentColor);
  cmock_call_instance = (CMOCK_GetSupportedComponentColor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetSupportedComponentColor_CallInstance);
  Mock.GetSupportedComponentColor_CallInstance = CMock_Guts_MemNext(Mock.GetSupportedComponentColor_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetSupportedComponentColor,CMockString_blComponentColor);
    if (cmock_call_instance->Expected_blComponentColor == NULL)
      { UNITY_TEST_ASSERT_NULL(blComponentColor, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_blComponentColor, blComponentColor, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetSupportedComponentColor(CMOCK_GetSupportedComponentColor_CALL_INSTANCE* cmock_call_instance, int* blComponentColor);
void CMockExpectParameters_GetSupportedComponentColor(CMOCK_GetSupportedComponentColor_CALL_INSTANCE* cmock_call_instance, int* blComponentColor)
{
  cmock_call_instance->Expected_blComponentColor = blComponentColor;
}

void GetSupportedComponentColor_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* blComponentColor, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetSupportedComponentColor_CALL_INSTANCE));
  CMOCK_GetSupportedComponentColor_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetSupportedComponentColor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetSupportedComponentColor_CallInstance = CMock_Guts_MemChain(Mock.GetSupportedComponentColor_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetSupportedComponentColor(cmock_call_instance, blComponentColor);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetCurrentComponentSaturation(tvDataComponentColor_t blSaturationColor, int saturation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetCurrentComponentSaturation_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetCurrentComponentSaturation);
  cmock_call_instance = (CMOCK_SetCurrentComponentSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetCurrentComponentSaturation_CallInstance);
  Mock.SetCurrentComponentSaturation_CallInstance = CMock_Guts_MemNext(Mock.SetCurrentComponentSaturation_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetCurrentComponentSaturation,CMockString_blSaturationColor);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_blSaturationColor), (void*)(&blSaturationColor), sizeof(tvDataComponentColor_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetCurrentComponentSaturation,CMockString_saturation);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_saturation, saturation, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetCurrentComponentSaturation(CMOCK_SetCurrentComponentSaturation_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blSaturationColor, int saturation);
void CMockExpectParameters_SetCurrentComponentSaturation(CMOCK_SetCurrentComponentSaturation_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blSaturationColor, int saturation)
{
  memcpy((void*)(&cmock_call_instance->Expected_blSaturationColor), (void*)(&blSaturationColor),
         sizeof(tvDataComponentColor_t[sizeof(blSaturationColor) == sizeof(tvDataComponentColor_t) ? 1 : -1])); /* add tvDataComponentColor_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_saturation = saturation;
}

void SetCurrentComponentSaturation_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvDataComponentColor_t blSaturationColor, int saturation, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetCurrentComponentSaturation_CALL_INSTANCE));
  CMOCK_SetCurrentComponentSaturation_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetCurrentComponentSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetCurrentComponentSaturation_CallInstance = CMock_Guts_MemChain(Mock.SetCurrentComponentSaturation_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetCurrentComponentSaturation(cmock_call_instance, blSaturationColor, saturation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetCurrentComponentSaturation(tvDataComponentColor_t blSaturationColor, int* saturation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetCurrentComponentSaturation_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetCurrentComponentSaturation);
  cmock_call_instance = (CMOCK_GetCurrentComponentSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetCurrentComponentSaturation_CallInstance);
  Mock.GetCurrentComponentSaturation_CallInstance = CMock_Guts_MemNext(Mock.GetCurrentComponentSaturation_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetCurrentComponentSaturation,CMockString_blSaturationColor);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_blSaturationColor), (void*)(&blSaturationColor), sizeof(tvDataComponentColor_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetCurrentComponentSaturation,CMockString_saturation);
    if (cmock_call_instance->Expected_saturation == NULL)
      { UNITY_TEST_ASSERT_NULL(saturation, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_saturation, saturation, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetCurrentComponentSaturation(CMOCK_GetCurrentComponentSaturation_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blSaturationColor, int* saturation);
void CMockExpectParameters_GetCurrentComponentSaturation(CMOCK_GetCurrentComponentSaturation_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blSaturationColor, int* saturation)
{
  memcpy((void*)(&cmock_call_instance->Expected_blSaturationColor), (void*)(&blSaturationColor),
         sizeof(tvDataComponentColor_t[sizeof(blSaturationColor) == sizeof(tvDataComponentColor_t) ? 1 : -1])); /* add tvDataComponentColor_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_saturation = saturation;
}

void GetCurrentComponentSaturation_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvDataComponentColor_t blSaturationColor, int* saturation, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetCurrentComponentSaturation_CALL_INSTANCE));
  CMOCK_GetCurrentComponentSaturation_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetCurrentComponentSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetCurrentComponentSaturation_CallInstance = CMock_Guts_MemChain(Mock.GetCurrentComponentSaturation_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetCurrentComponentSaturation(cmock_call_instance, blSaturationColor, saturation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetCurrentComponentHue(tvDataComponentColor_t blHueColor, int hue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetCurrentComponentHue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetCurrentComponentHue);
  cmock_call_instance = (CMOCK_SetCurrentComponentHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetCurrentComponentHue_CallInstance);
  Mock.SetCurrentComponentHue_CallInstance = CMock_Guts_MemNext(Mock.SetCurrentComponentHue_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetCurrentComponentHue,CMockString_blHueColor);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_blHueColor), (void*)(&blHueColor), sizeof(tvDataComponentColor_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetCurrentComponentHue,CMockString_hue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hue, hue, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetCurrentComponentHue(CMOCK_SetCurrentComponentHue_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blHueColor, int hue);
void CMockExpectParameters_SetCurrentComponentHue(CMOCK_SetCurrentComponentHue_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blHueColor, int hue)
{
  memcpy((void*)(&cmock_call_instance->Expected_blHueColor), (void*)(&blHueColor),
         sizeof(tvDataComponentColor_t[sizeof(blHueColor) == sizeof(tvDataComponentColor_t) ? 1 : -1])); /* add tvDataComponentColor_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hue = hue;
}

void SetCurrentComponentHue_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvDataComponentColor_t blHueColor, int hue, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetCurrentComponentHue_CALL_INSTANCE));
  CMOCK_SetCurrentComponentHue_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetCurrentComponentHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetCurrentComponentHue_CallInstance = CMock_Guts_MemChain(Mock.SetCurrentComponentHue_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetCurrentComponentHue(cmock_call_instance, blHueColor, hue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetCurrentComponentHue(tvDataComponentColor_t blHueColor, int* hue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetCurrentComponentHue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetCurrentComponentHue);
  cmock_call_instance = (CMOCK_GetCurrentComponentHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetCurrentComponentHue_CallInstance);
  Mock.GetCurrentComponentHue_CallInstance = CMock_Guts_MemNext(Mock.GetCurrentComponentHue_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetCurrentComponentHue,CMockString_blHueColor);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_blHueColor), (void*)(&blHueColor), sizeof(tvDataComponentColor_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetCurrentComponentHue,CMockString_hue);
    if (cmock_call_instance->Expected_hue == NULL)
      { UNITY_TEST_ASSERT_NULL(hue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_hue, hue, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetCurrentComponentHue(CMOCK_GetCurrentComponentHue_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blHueColor, int* hue);
void CMockExpectParameters_GetCurrentComponentHue(CMOCK_GetCurrentComponentHue_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blHueColor, int* hue)
{
  memcpy((void*)(&cmock_call_instance->Expected_blHueColor), (void*)(&blHueColor),
         sizeof(tvDataComponentColor_t[sizeof(blHueColor) == sizeof(tvDataComponentColor_t) ? 1 : -1])); /* add tvDataComponentColor_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hue = hue;
}

void GetCurrentComponentHue_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvDataComponentColor_t blHueColor, int* hue, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetCurrentComponentHue_CALL_INSTANCE));
  CMOCK_GetCurrentComponentHue_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetCurrentComponentHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetCurrentComponentHue_CallInstance = CMock_Guts_MemChain(Mock.GetCurrentComponentHue_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetCurrentComponentHue(cmock_call_instance, blHueColor, hue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetCurrentComponentLuma(tvDataComponentColor_t blLumaColor, int Luma)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetCurrentComponentLuma_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetCurrentComponentLuma);
  cmock_call_instance = (CMOCK_SetCurrentComponentLuma_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetCurrentComponentLuma_CallInstance);
  Mock.SetCurrentComponentLuma_CallInstance = CMock_Guts_MemNext(Mock.SetCurrentComponentLuma_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetCurrentComponentLuma,CMockString_blLumaColor);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_blLumaColor), (void*)(&blLumaColor), sizeof(tvDataComponentColor_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetCurrentComponentLuma,CMockString_Luma);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_Luma, Luma, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetCurrentComponentLuma(CMOCK_SetCurrentComponentLuma_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blLumaColor, int Luma);
void CMockExpectParameters_SetCurrentComponentLuma(CMOCK_SetCurrentComponentLuma_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blLumaColor, int Luma)
{
  memcpy((void*)(&cmock_call_instance->Expected_blLumaColor), (void*)(&blLumaColor),
         sizeof(tvDataComponentColor_t[sizeof(blLumaColor) == sizeof(tvDataComponentColor_t) ? 1 : -1])); /* add tvDataComponentColor_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_Luma = Luma;
}

void SetCurrentComponentLuma_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvDataComponentColor_t blLumaColor, int Luma, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetCurrentComponentLuma_CALL_INSTANCE));
  CMOCK_SetCurrentComponentLuma_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetCurrentComponentLuma_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetCurrentComponentLuma_CallInstance = CMock_Guts_MemChain(Mock.SetCurrentComponentLuma_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetCurrentComponentLuma(cmock_call_instance, blLumaColor, Luma);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetCurrentComponentLuma(tvDataComponentColor_t blLumaColor, int* Luma)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetCurrentComponentLuma_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetCurrentComponentLuma);
  cmock_call_instance = (CMOCK_GetCurrentComponentLuma_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetCurrentComponentLuma_CallInstance);
  Mock.GetCurrentComponentLuma_CallInstance = CMock_Guts_MemNext(Mock.GetCurrentComponentLuma_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetCurrentComponentLuma,CMockString_blLumaColor);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_blLumaColor), (void*)(&blLumaColor), sizeof(tvDataComponentColor_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetCurrentComponentLuma,CMockString_Luma);
    if (cmock_call_instance->Expected_Luma == NULL)
      { UNITY_TEST_ASSERT_NULL(Luma, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_Luma, Luma, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetCurrentComponentLuma(CMOCK_GetCurrentComponentLuma_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blLumaColor, int* Luma);
void CMockExpectParameters_GetCurrentComponentLuma(CMOCK_GetCurrentComponentLuma_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blLumaColor, int* Luma)
{
  memcpy((void*)(&cmock_call_instance->Expected_blLumaColor), (void*)(&blLumaColor),
         sizeof(tvDataComponentColor_t[sizeof(blLumaColor) == sizeof(tvDataComponentColor_t) ? 1 : -1])); /* add tvDataComponentColor_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_Luma = Luma;
}

void GetCurrentComponentLuma_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvDataComponentColor_t blLumaColor, int* Luma, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetCurrentComponentLuma_CALL_INSTANCE));
  CMOCK_GetCurrentComponentLuma_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetCurrentComponentLuma_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetCurrentComponentLuma_CallInstance = CMock_Guts_MemChain(Mock.GetCurrentComponentLuma_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetCurrentComponentLuma(cmock_call_instance, blLumaColor, Luma);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetTVSupportedDimmingModes(char** dimmingModes, unsigned short* count)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetTVSupportedDimmingModes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetTVSupportedDimmingModes);
  cmock_call_instance = (CMOCK_GetTVSupportedDimmingModes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetTVSupportedDimmingModes_CallInstance);
  Mock.GetTVSupportedDimmingModes_CallInstance = CMock_Guts_MemNext(Mock.GetTVSupportedDimmingModes_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetTVSupportedDimmingModes,CMockString_dimmingModes);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_dimmingModes, dimmingModes, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetTVSupportedDimmingModes,CMockString_count);
    if (cmock_call_instance->Expected_count == NULL)
      { UNITY_TEST_ASSERT_NULL(count, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_count, count, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetTVSupportedDimmingModes(CMOCK_GetTVSupportedDimmingModes_CALL_INSTANCE* cmock_call_instance, char** dimmingModes, unsigned short* count);
void CMockExpectParameters_GetTVSupportedDimmingModes(CMOCK_GetTVSupportedDimmingModes_CALL_INSTANCE* cmock_call_instance, char** dimmingModes, unsigned short* count)
{
  cmock_call_instance->Expected_dimmingModes = dimmingModes;
  cmock_call_instance->Expected_count = count;
}

void GetTVSupportedDimmingModes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char** dimmingModes, unsigned short* count, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetTVSupportedDimmingModes_CALL_INSTANCE));
  CMOCK_GetTVSupportedDimmingModes_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetTVSupportedDimmingModes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetTVSupportedDimmingModes_CallInstance = CMock_Guts_MemChain(Mock.GetTVSupportedDimmingModes_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetTVSupportedDimmingModes(cmock_call_instance, dimmingModes, count);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetTVDimmingMode(const char* dimmingMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetTVDimmingMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetTVDimmingMode);
  cmock_call_instance = (CMOCK_SetTVDimmingMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetTVDimmingMode_CallInstance);
  Mock.SetTVDimmingMode_CallInstance = CMock_Guts_MemNext(Mock.SetTVDimmingMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetTVDimmingMode,CMockString_dimmingMode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_dimmingMode, dimmingMode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetTVDimmingMode(CMOCK_SetTVDimmingMode_CALL_INSTANCE* cmock_call_instance, const char* dimmingMode);
void CMockExpectParameters_SetTVDimmingMode(CMOCK_SetTVDimmingMode_CALL_INSTANCE* cmock_call_instance, const char* dimmingMode)
{
  cmock_call_instance->Expected_dimmingMode = dimmingMode;
}

void SetTVDimmingMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* dimmingMode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetTVDimmingMode_CALL_INSTANCE));
  CMOCK_SetTVDimmingMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetTVDimmingMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetTVDimmingMode_CallInstance = CMock_Guts_MemChain(Mock.SetTVDimmingMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetTVDimmingMode(cmock_call_instance, dimmingMode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetTVBacklightGlobalFactor(int* value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetTVBacklightGlobalFactor_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetTVBacklightGlobalFactor);
  cmock_call_instance = (CMOCK_GetTVBacklightGlobalFactor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetTVBacklightGlobalFactor_CallInstance);
  Mock.GetTVBacklightGlobalFactor_CallInstance = CMock_Guts_MemNext(Mock.GetTVBacklightGlobalFactor_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetTVBacklightGlobalFactor,CMockString_value);
    if (cmock_call_instance->Expected_value == NULL)
      { UNITY_TEST_ASSERT_NULL(value, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_value, value, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetTVBacklightGlobalFactor(CMOCK_GetTVBacklightGlobalFactor_CALL_INSTANCE* cmock_call_instance, int* value);
void CMockExpectParameters_GetTVBacklightGlobalFactor(CMOCK_GetTVBacklightGlobalFactor_CALL_INSTANCE* cmock_call_instance, int* value)
{
  cmock_call_instance->Expected_value = value;
}

void GetTVBacklightGlobalFactor_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetTVBacklightGlobalFactor_CALL_INSTANCE));
  CMOCK_GetTVBacklightGlobalFactor_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetTVBacklightGlobalFactor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetTVBacklightGlobalFactor_CallInstance = CMock_Guts_MemChain(Mock.GetTVBacklightGlobalFactor_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetTVBacklightGlobalFactor(cmock_call_instance, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetTVBacklightGlobalFactor(int value, int rangeMidPointValue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetTVBacklightGlobalFactor_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetTVBacklightGlobalFactor);
  cmock_call_instance = (CMOCK_SetTVBacklightGlobalFactor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetTVBacklightGlobalFactor_CallInstance);
  Mock.SetTVBacklightGlobalFactor_CallInstance = CMock_Guts_MemNext(Mock.SetTVBacklightGlobalFactor_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetTVBacklightGlobalFactor,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetTVBacklightGlobalFactor,CMockString_rangeMidPointValue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_rangeMidPointValue, rangeMidPointValue, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetTVBacklightGlobalFactor(CMOCK_SetTVBacklightGlobalFactor_CALL_INSTANCE* cmock_call_instance, int value, int rangeMidPointValue);
void CMockExpectParameters_SetTVBacklightGlobalFactor(CMOCK_SetTVBacklightGlobalFactor_CALL_INSTANCE* cmock_call_instance, int value, int rangeMidPointValue)
{
  cmock_call_instance->Expected_value = value;
  cmock_call_instance->Expected_rangeMidPointValue = rangeMidPointValue;
}

void SetTVBacklightGlobalFactor_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int value, int rangeMidPointValue, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetTVBacklightGlobalFactor_CALL_INSTANCE));
  CMOCK_SetTVBacklightGlobalFactor_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetTVBacklightGlobalFactor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetTVBacklightGlobalFactor_CallInstance = CMock_Guts_MemChain(Mock.SetTVBacklightGlobalFactor_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetTVBacklightGlobalFactor(cmock_call_instance, value, rangeMidPointValue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvPictureMode_t GetTVPictureModeIndex(const char* pictureMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetTVPictureModeIndex_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetTVPictureModeIndex);
  cmock_call_instance = (CMOCK_GetTVPictureModeIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetTVPictureModeIndex_CallInstance);
  Mock.GetTVPictureModeIndex_CallInstance = CMock_Guts_MemNext(Mock.GetTVPictureModeIndex_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetTVPictureModeIndex,CMockString_pictureMode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pictureMode, pictureMode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetTVPictureModeIndex(CMOCK_GetTVPictureModeIndex_CALL_INSTANCE* cmock_call_instance, const char* pictureMode);
void CMockExpectParameters_GetTVPictureModeIndex(CMOCK_GetTVPictureModeIndex_CALL_INSTANCE* cmock_call_instance, const char* pictureMode)
{
  cmock_call_instance->Expected_pictureMode = pictureMode;
}

void GetTVPictureModeIndex_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* pictureMode, tvPictureMode_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetTVPictureModeIndex_CALL_INSTANCE));
  CMOCK_GetTVPictureModeIndex_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetTVPictureModeIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetTVPictureModeIndex_CallInstance = CMock_Guts_MemChain(Mock.GetTVPictureModeIndex_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetTVPictureModeIndex(cmock_call_instance, pictureMode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvPictureMode_t[sizeof(cmock_to_return) == sizeof(tvPictureMode_t) ? 1 : -1])); /* add tvPictureMode_t to :treat_as_array if this causes an error */
}

tvVideoHDRFormat_t GetCurrentContentFormat(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetCurrentContentFormat_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetCurrentContentFormat);
  cmock_call_instance = (CMOCK_GetCurrentContentFormat_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetCurrentContentFormat_CallInstance);
  Mock.GetCurrentContentFormat_CallInstance = CMock_Guts_MemNext(Mock.GetCurrentContentFormat_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void GetCurrentContentFormat_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvVideoHDRFormat_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetCurrentContentFormat_CALL_INSTANCE));
  CMOCK_GetCurrentContentFormat_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetCurrentContentFormat_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetCurrentContentFormat_CallInstance = CMock_Guts_MemChain(Mock.GetCurrentContentFormat_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvVideoHDRFormat_t[sizeof(cmock_to_return) == sizeof(tvVideoHDRFormat_t) ? 1 : -1])); /* add tvVideoHDRFormat_t to :treat_as_array if this causes an error */
}

tvError_t GetSupportedContentFormats(unsigned int* contentFormats, unsigned short* numberOfFormats)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetSupportedContentFormats_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetSupportedContentFormats);
  cmock_call_instance = (CMOCK_GetSupportedContentFormats_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetSupportedContentFormats_CallInstance);
  Mock.GetSupportedContentFormats_CallInstance = CMock_Guts_MemNext(Mock.GetSupportedContentFormats_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetSupportedContentFormats,CMockString_contentFormats);
    if (cmock_call_instance->Expected_contentFormats == NULL)
      { UNITY_TEST_ASSERT_NULL(contentFormats, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_contentFormats, contentFormats, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_GetSupportedContentFormats,CMockString_numberOfFormats);
    if (cmock_call_instance->Expected_numberOfFormats == NULL)
      { UNITY_TEST_ASSERT_NULL(numberOfFormats, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_numberOfFormats, numberOfFormats, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetSupportedContentFormats(CMOCK_GetSupportedContentFormats_CALL_INSTANCE* cmock_call_instance, unsigned int* contentFormats, unsigned short* numberOfFormats);
void CMockExpectParameters_GetSupportedContentFormats(CMOCK_GetSupportedContentFormats_CALL_INSTANCE* cmock_call_instance, unsigned int* contentFormats, unsigned short* numberOfFormats)
{
  cmock_call_instance->Expected_contentFormats = contentFormats;
  cmock_call_instance->Expected_numberOfFormats = numberOfFormats;
}

void GetSupportedContentFormats_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, unsigned int* contentFormats, unsigned short* numberOfFormats, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetSupportedContentFormats_CALL_INSTANCE));
  CMOCK_GetSupportedContentFormats_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetSupportedContentFormats_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetSupportedContentFormats_CallInstance = CMock_Guts_MemChain(Mock.GetSupportedContentFormats_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetSupportedContentFormats(cmock_call_instance, contentFormats, numberOfFormats);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t ResetBrightness(int defaultValue, bool resetForAllFormats)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ResetBrightness_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ResetBrightness);
  cmock_call_instance = (CMOCK_ResetBrightness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ResetBrightness_CallInstance);
  Mock.ResetBrightness_CallInstance = CMock_Guts_MemNext(Mock.ResetBrightness_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ResetBrightness,CMockString_defaultValue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_defaultValue, defaultValue, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ResetBrightness,CMockString_resetForAllFormats);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_resetForAllFormats, resetForAllFormats, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ResetBrightness(CMOCK_ResetBrightness_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats);
void CMockExpectParameters_ResetBrightness(CMOCK_ResetBrightness_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats)
{
  cmock_call_instance->Expected_defaultValue = defaultValue;
  cmock_call_instance->Expected_resetForAllFormats = resetForAllFormats;
}

void ResetBrightness_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int defaultValue, bool resetForAllFormats, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ResetBrightness_CALL_INSTANCE));
  CMOCK_ResetBrightness_CALL_INSTANCE* cmock_call_instance = (CMOCK_ResetBrightness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ResetBrightness_CallInstance = CMock_Guts_MemChain(Mock.ResetBrightness_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ResetBrightness(cmock_call_instance, defaultValue, resetForAllFormats);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t ResetContrast(int defaultValue, bool resetForAllFormats)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ResetContrast_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ResetContrast);
  cmock_call_instance = (CMOCK_ResetContrast_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ResetContrast_CallInstance);
  Mock.ResetContrast_CallInstance = CMock_Guts_MemNext(Mock.ResetContrast_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ResetContrast,CMockString_defaultValue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_defaultValue, defaultValue, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ResetContrast,CMockString_resetForAllFormats);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_resetForAllFormats, resetForAllFormats, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ResetContrast(CMOCK_ResetContrast_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats);
void CMockExpectParameters_ResetContrast(CMOCK_ResetContrast_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats)
{
  cmock_call_instance->Expected_defaultValue = defaultValue;
  cmock_call_instance->Expected_resetForAllFormats = resetForAllFormats;
}

void ResetContrast_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int defaultValue, bool resetForAllFormats, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ResetContrast_CALL_INSTANCE));
  CMOCK_ResetContrast_CALL_INSTANCE* cmock_call_instance = (CMOCK_ResetContrast_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ResetContrast_CallInstance = CMock_Guts_MemChain(Mock.ResetContrast_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ResetContrast(cmock_call_instance, defaultValue, resetForAllFormats);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t ResetSharpness(int defaultValue, bool resetForAllFormats)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ResetSharpness_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ResetSharpness);
  cmock_call_instance = (CMOCK_ResetSharpness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ResetSharpness_CallInstance);
  Mock.ResetSharpness_CallInstance = CMock_Guts_MemNext(Mock.ResetSharpness_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ResetSharpness,CMockString_defaultValue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_defaultValue, defaultValue, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ResetSharpness,CMockString_resetForAllFormats);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_resetForAllFormats, resetForAllFormats, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ResetSharpness(CMOCK_ResetSharpness_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats);
void CMockExpectParameters_ResetSharpness(CMOCK_ResetSharpness_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats)
{
  cmock_call_instance->Expected_defaultValue = defaultValue;
  cmock_call_instance->Expected_resetForAllFormats = resetForAllFormats;
}

void ResetSharpness_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int defaultValue, bool resetForAllFormats, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ResetSharpness_CALL_INSTANCE));
  CMOCK_ResetSharpness_CALL_INSTANCE* cmock_call_instance = (CMOCK_ResetSharpness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ResetSharpness_CallInstance = CMock_Guts_MemChain(Mock.ResetSharpness_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ResetSharpness(cmock_call_instance, defaultValue, resetForAllFormats);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t ResetSaturation(int defaultValue, bool resetForAllFormats)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ResetSaturation_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ResetSaturation);
  cmock_call_instance = (CMOCK_ResetSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ResetSaturation_CallInstance);
  Mock.ResetSaturation_CallInstance = CMock_Guts_MemNext(Mock.ResetSaturation_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ResetSaturation,CMockString_defaultValue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_defaultValue, defaultValue, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ResetSaturation,CMockString_resetForAllFormats);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_resetForAllFormats, resetForAllFormats, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ResetSaturation(CMOCK_ResetSaturation_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats);
void CMockExpectParameters_ResetSaturation(CMOCK_ResetSaturation_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats)
{
  cmock_call_instance->Expected_defaultValue = defaultValue;
  cmock_call_instance->Expected_resetForAllFormats = resetForAllFormats;
}

void ResetSaturation_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int defaultValue, bool resetForAllFormats, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ResetSaturation_CALL_INSTANCE));
  CMOCK_ResetSaturation_CALL_INSTANCE* cmock_call_instance = (CMOCK_ResetSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ResetSaturation_CallInstance = CMock_Guts_MemChain(Mock.ResetSaturation_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ResetSaturation(cmock_call_instance, defaultValue, resetForAllFormats);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t ResetHue(int defaultValue, bool resetForAllFormats)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ResetHue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ResetHue);
  cmock_call_instance = (CMOCK_ResetHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ResetHue_CallInstance);
  Mock.ResetHue_CallInstance = CMock_Guts_MemNext(Mock.ResetHue_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ResetHue,CMockString_defaultValue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_defaultValue, defaultValue, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ResetHue,CMockString_resetForAllFormats);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_resetForAllFormats, resetForAllFormats, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ResetHue(CMOCK_ResetHue_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats);
void CMockExpectParameters_ResetHue(CMOCK_ResetHue_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats)
{
  cmock_call_instance->Expected_defaultValue = defaultValue;
  cmock_call_instance->Expected_resetForAllFormats = resetForAllFormats;
}

void ResetHue_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int defaultValue, bool resetForAllFormats, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ResetHue_CALL_INSTANCE));
  CMOCK_ResetHue_CALL_INSTANCE* cmock_call_instance = (CMOCK_ResetHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ResetHue_CallInstance = CMock_Guts_MemChain(Mock.ResetHue_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ResetHue(cmock_call_instance, defaultValue, resetForAllFormats);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t ResetBacklight(int defaultValue, bool resetForAllFormats)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ResetBacklight_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ResetBacklight);
  cmock_call_instance = (CMOCK_ResetBacklight_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ResetBacklight_CallInstance);
  Mock.ResetBacklight_CallInstance = CMock_Guts_MemNext(Mock.ResetBacklight_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ResetBacklight,CMockString_defaultValue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_defaultValue, defaultValue, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ResetBacklight,CMockString_resetForAllFormats);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_resetForAllFormats, resetForAllFormats, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ResetBacklight(CMOCK_ResetBacklight_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats);
void CMockExpectParameters_ResetBacklight(CMOCK_ResetBacklight_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats)
{
  cmock_call_instance->Expected_defaultValue = defaultValue;
  cmock_call_instance->Expected_resetForAllFormats = resetForAllFormats;
}

void ResetBacklight_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int defaultValue, bool resetForAllFormats, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ResetBacklight_CALL_INSTANCE));
  CMOCK_ResetBacklight_CALL_INSTANCE* cmock_call_instance = (CMOCK_ResetBacklight_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ResetBacklight_CallInstance = CMock_Guts_MemChain(Mock.ResetBacklight_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ResetBacklight(cmock_call_instance, defaultValue, resetForAllFormats);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t ResetColorTemperature(int defaultValue, bool resetForAllFormats)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ResetColorTemperature_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ResetColorTemperature);
  cmock_call_instance = (CMOCK_ResetColorTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ResetColorTemperature_CallInstance);
  Mock.ResetColorTemperature_CallInstance = CMock_Guts_MemNext(Mock.ResetColorTemperature_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ResetColorTemperature,CMockString_defaultValue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_defaultValue, defaultValue, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ResetColorTemperature,CMockString_resetForAllFormats);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_resetForAllFormats, resetForAllFormats, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ResetColorTemperature(CMOCK_ResetColorTemperature_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats);
void CMockExpectParameters_ResetColorTemperature(CMOCK_ResetColorTemperature_CALL_INSTANCE* cmock_call_instance, int defaultValue, bool resetForAllFormats)
{
  cmock_call_instance->Expected_defaultValue = defaultValue;
  cmock_call_instance->Expected_resetForAllFormats = resetForAllFormats;
}

void ResetColorTemperature_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int defaultValue, bool resetForAllFormats, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ResetColorTemperature_CALL_INSTANCE));
  CMOCK_ResetColorTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_ResetColorTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ResetColorTemperature_CallInstance = CMock_Guts_MemChain(Mock.ResetColorTemperature_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ResetColorTemperature(cmock_call_instance, defaultValue, resetForAllFormats);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t ResetComponentSaturation(int color, int defaultValue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ResetComponentSaturation_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ResetComponentSaturation);
  cmock_call_instance = (CMOCK_ResetComponentSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ResetComponentSaturation_CallInstance);
  Mock.ResetComponentSaturation_CallInstance = CMock_Guts_MemNext(Mock.ResetComponentSaturation_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ResetComponentSaturation,CMockString_color);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_color, color, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ResetComponentSaturation,CMockString_defaultValue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_defaultValue, defaultValue, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ResetComponentSaturation(CMOCK_ResetComponentSaturation_CALL_INSTANCE* cmock_call_instance, int color, int defaultValue);
void CMockExpectParameters_ResetComponentSaturation(CMOCK_ResetComponentSaturation_CALL_INSTANCE* cmock_call_instance, int color, int defaultValue)
{
  cmock_call_instance->Expected_color = color;
  cmock_call_instance->Expected_defaultValue = defaultValue;
}

void ResetComponentSaturation_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int color, int defaultValue, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ResetComponentSaturation_CALL_INSTANCE));
  CMOCK_ResetComponentSaturation_CALL_INSTANCE* cmock_call_instance = (CMOCK_ResetComponentSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ResetComponentSaturation_CallInstance = CMock_Guts_MemChain(Mock.ResetComponentSaturation_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ResetComponentSaturation(cmock_call_instance, color, defaultValue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t ResetComponentLuma(int color, int defaultValue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ResetComponentLuma_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ResetComponentLuma);
  cmock_call_instance = (CMOCK_ResetComponentLuma_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ResetComponentLuma_CallInstance);
  Mock.ResetComponentLuma_CallInstance = CMock_Guts_MemNext(Mock.ResetComponentLuma_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ResetComponentLuma,CMockString_color);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_color, color, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ResetComponentLuma,CMockString_defaultValue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_defaultValue, defaultValue, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ResetComponentLuma(CMOCK_ResetComponentLuma_CALL_INSTANCE* cmock_call_instance, int color, int defaultValue);
void CMockExpectParameters_ResetComponentLuma(CMOCK_ResetComponentLuma_CALL_INSTANCE* cmock_call_instance, int color, int defaultValue)
{
  cmock_call_instance->Expected_color = color;
  cmock_call_instance->Expected_defaultValue = defaultValue;
}

void ResetComponentLuma_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int color, int defaultValue, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ResetComponentLuma_CALL_INSTANCE));
  CMOCK_ResetComponentLuma_CALL_INSTANCE* cmock_call_instance = (CMOCK_ResetComponentLuma_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ResetComponentLuma_CallInstance = CMock_Guts_MemChain(Mock.ResetComponentLuma_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ResetComponentLuma(cmock_call_instance, color, defaultValue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t ResetComponentHue(int color, int defaultValue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ResetComponentHue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ResetComponentHue);
  cmock_call_instance = (CMOCK_ResetComponentHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ResetComponentHue_CallInstance);
  Mock.ResetComponentHue_CallInstance = CMock_Guts_MemNext(Mock.ResetComponentHue_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ResetComponentHue,CMockString_color);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_color, color, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ResetComponentHue,CMockString_defaultValue);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_defaultValue, defaultValue, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ResetComponentHue(CMOCK_ResetComponentHue_CALL_INSTANCE* cmock_call_instance, int color, int defaultValue);
void CMockExpectParameters_ResetComponentHue(CMOCK_ResetComponentHue_CALL_INSTANCE* cmock_call_instance, int color, int defaultValue)
{
  cmock_call_instance->Expected_color = color;
  cmock_call_instance->Expected_defaultValue = defaultValue;
}

void ResetComponentHue_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int color, int defaultValue, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ResetComponentHue_CALL_INSTANCE));
  CMOCK_ResetComponentHue_CALL_INSTANCE* cmock_call_instance = (CMOCK_ResetComponentHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ResetComponentHue_CallInstance = CMock_Guts_MemChain(Mock.ResetComponentHue_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ResetComponentHue(cmock_call_instance, color, defaultValue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

bool isCurrentHDRTypeIsSDR(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_isCurrentHDRTypeIsSDR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_isCurrentHDRTypeIsSDR);
  cmock_call_instance = (CMOCK_isCurrentHDRTypeIsSDR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.isCurrentHDRTypeIsSDR_CallInstance);
  Mock.isCurrentHDRTypeIsSDR_CallInstance = CMock_Guts_MemNext(Mock.isCurrentHDRTypeIsSDR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void isCurrentHDRTypeIsSDR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_isCurrentHDRTypeIsSDR_CALL_INSTANCE));
  CMOCK_isCurrentHDRTypeIsSDR_CALL_INSTANCE* cmock_call_instance = (CMOCK_isCurrentHDRTypeIsSDR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.isCurrentHDRTypeIsSDR_CallInstance = CMock_Guts_MemChain(Mock.isCurrentHDRTypeIsSDR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int GetPanelID(char* panelid)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetPanelID_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetPanelID);
  cmock_call_instance = (CMOCK_GetPanelID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetPanelID_CallInstance);
  Mock.GetPanelID_CallInstance = CMock_Guts_MemNext(Mock.GetPanelID_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetPanelID,CMockString_panelid);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_panelid, panelid, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetPanelID(CMOCK_GetPanelID_CALL_INSTANCE* cmock_call_instance, char* panelid);
void CMockExpectParameters_GetPanelID(CMOCK_GetPanelID_CALL_INSTANCE* cmock_call_instance, char* panelid)
{
  cmock_call_instance->Expected_panelid = panelid;
}

void GetPanelID_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* panelid, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetPanelID_CALL_INSTANCE));
  CMOCK_GetPanelID_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetPanelID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetPanelID_CallInstance = CMock_Guts_MemChain(Mock.GetPanelID_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetPanelID(cmock_call_instance, panelid);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void GetDefaultPanelID(char* panelID)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetDefaultPanelID_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetDefaultPanelID);
  cmock_call_instance = (CMOCK_GetDefaultPanelID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetDefaultPanelID_CallInstance);
  Mock.GetDefaultPanelID_CallInstance = CMock_Guts_MemNext(Mock.GetDefaultPanelID_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetDefaultPanelID,CMockString_panelID);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_panelID, panelID, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GetDefaultPanelID(CMOCK_GetDefaultPanelID_CALL_INSTANCE* cmock_call_instance, char* panelID);
void CMockExpectParameters_GetDefaultPanelID(CMOCK_GetDefaultPanelID_CALL_INSTANCE* cmock_call_instance, char* panelID)
{
  cmock_call_instance->Expected_panelID = panelID;
}

void GetDefaultPanelID_CMockExpect(UNITY_LINE_TYPE cmock_line, char* panelID)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetDefaultPanelID_CALL_INSTANCE));
  CMOCK_GetDefaultPanelID_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetDefaultPanelID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetDefaultPanelID_CallInstance = CMock_Guts_MemChain(Mock.GetDefaultPanelID_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetDefaultPanelID(cmock_call_instance, panelID);
}

tvError_t SaveColorTemperature(int sourceInput, int pq_mode, int hdr_type, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveColorTemperature_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveColorTemperature);
  cmock_call_instance = (CMOCK_SaveColorTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveColorTemperature_CallInstance);
  Mock.SaveColorTemperature_CallInstance = CMock_Guts_MemNext(Mock.SaveColorTemperature_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveColorTemperature,CMockString_sourceInput);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceInput, sourceInput, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveColorTemperature,CMockString_pq_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pq_mode, pq_mode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveColorTemperature,CMockString_hdr_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hdr_type, hdr_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveColorTemperature,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveColorTemperature(CMOCK_SaveColorTemperature_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value);
void CMockExpectParameters_SaveColorTemperature(CMOCK_SaveColorTemperature_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value)
{
  cmock_call_instance->Expected_sourceInput = sourceInput;
  cmock_call_instance->Expected_pq_mode = pq_mode;
  cmock_call_instance->Expected_hdr_type = hdr_type;
  cmock_call_instance->Expected_value = value;
}

void SaveColorTemperature_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sourceInput, int pq_mode, int hdr_type, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveColorTemperature_CALL_INSTANCE));
  CMOCK_SaveColorTemperature_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveColorTemperature_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveColorTemperature_CallInstance = CMock_Guts_MemChain(Mock.SaveColorTemperature_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveColorTemperature(cmock_call_instance, sourceInput, pq_mode, hdr_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SaveBacklight(int sourceInput, int pq_mode, int hdr_type, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveBacklight_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveBacklight);
  cmock_call_instance = (CMOCK_SaveBacklight_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveBacklight_CallInstance);
  Mock.SaveBacklight_CallInstance = CMock_Guts_MemNext(Mock.SaveBacklight_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveBacklight,CMockString_sourceInput);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceInput, sourceInput, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveBacklight,CMockString_pq_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pq_mode, pq_mode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveBacklight,CMockString_hdr_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hdr_type, hdr_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveBacklight,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveBacklight(CMOCK_SaveBacklight_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value);
void CMockExpectParameters_SaveBacklight(CMOCK_SaveBacklight_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value)
{
  cmock_call_instance->Expected_sourceInput = sourceInput;
  cmock_call_instance->Expected_pq_mode = pq_mode;
  cmock_call_instance->Expected_hdr_type = hdr_type;
  cmock_call_instance->Expected_value = value;
}

void SaveBacklight_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sourceInput, int pq_mode, int hdr_type, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveBacklight_CALL_INSTANCE));
  CMOCK_SaveBacklight_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveBacklight_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveBacklight_CallInstance = CMock_Guts_MemChain(Mock.SaveBacklight_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveBacklight(cmock_call_instance, sourceInput, pq_mode, hdr_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SaveContrast(int sourceInput, int pq_mode, int hdr_type, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveContrast_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveContrast);
  cmock_call_instance = (CMOCK_SaveContrast_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveContrast_CallInstance);
  Mock.SaveContrast_CallInstance = CMock_Guts_MemNext(Mock.SaveContrast_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveContrast,CMockString_sourceInput);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceInput, sourceInput, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveContrast,CMockString_pq_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pq_mode, pq_mode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveContrast,CMockString_hdr_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hdr_type, hdr_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveContrast,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveContrast(CMOCK_SaveContrast_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value);
void CMockExpectParameters_SaveContrast(CMOCK_SaveContrast_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value)
{
  cmock_call_instance->Expected_sourceInput = sourceInput;
  cmock_call_instance->Expected_pq_mode = pq_mode;
  cmock_call_instance->Expected_hdr_type = hdr_type;
  cmock_call_instance->Expected_value = value;
}

void SaveContrast_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sourceInput, int pq_mode, int hdr_type, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveContrast_CALL_INSTANCE));
  CMOCK_SaveContrast_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveContrast_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveContrast_CallInstance = CMock_Guts_MemChain(Mock.SaveContrast_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveContrast(cmock_call_instance, sourceInput, pq_mode, hdr_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SaveSaturation(int sourceInput, int pq_mode, int hdr_type, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveSaturation_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveSaturation);
  cmock_call_instance = (CMOCK_SaveSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveSaturation_CallInstance);
  Mock.SaveSaturation_CallInstance = CMock_Guts_MemNext(Mock.SaveSaturation_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveSaturation,CMockString_sourceInput);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceInput, sourceInput, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveSaturation,CMockString_pq_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pq_mode, pq_mode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveSaturation,CMockString_hdr_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hdr_type, hdr_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveSaturation,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveSaturation(CMOCK_SaveSaturation_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value);
void CMockExpectParameters_SaveSaturation(CMOCK_SaveSaturation_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value)
{
  cmock_call_instance->Expected_sourceInput = sourceInput;
  cmock_call_instance->Expected_pq_mode = pq_mode;
  cmock_call_instance->Expected_hdr_type = hdr_type;
  cmock_call_instance->Expected_value = value;
}

void SaveSaturation_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sourceInput, int pq_mode, int hdr_type, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveSaturation_CALL_INSTANCE));
  CMOCK_SaveSaturation_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveSaturation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveSaturation_CallInstance = CMock_Guts_MemChain(Mock.SaveSaturation_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveSaturation(cmock_call_instance, sourceInput, pq_mode, hdr_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SaveSharpness(int sourceInput, int pq_mode, int hdr_type, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveSharpness_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveSharpness);
  cmock_call_instance = (CMOCK_SaveSharpness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveSharpness_CallInstance);
  Mock.SaveSharpness_CallInstance = CMock_Guts_MemNext(Mock.SaveSharpness_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveSharpness,CMockString_sourceInput);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceInput, sourceInput, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveSharpness,CMockString_pq_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pq_mode, pq_mode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveSharpness,CMockString_hdr_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hdr_type, hdr_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveSharpness,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveSharpness(CMOCK_SaveSharpness_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value);
void CMockExpectParameters_SaveSharpness(CMOCK_SaveSharpness_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value)
{
  cmock_call_instance->Expected_sourceInput = sourceInput;
  cmock_call_instance->Expected_pq_mode = pq_mode;
  cmock_call_instance->Expected_hdr_type = hdr_type;
  cmock_call_instance->Expected_value = value;
}

void SaveSharpness_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sourceInput, int pq_mode, int hdr_type, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveSharpness_CALL_INSTANCE));
  CMOCK_SaveSharpness_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveSharpness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveSharpness_CallInstance = CMock_Guts_MemChain(Mock.SaveSharpness_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveSharpness(cmock_call_instance, sourceInput, pq_mode, hdr_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SaveBrightness(int sourceInput, int pq_mode, int hdr_type, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveBrightness_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveBrightness);
  cmock_call_instance = (CMOCK_SaveBrightness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveBrightness_CallInstance);
  Mock.SaveBrightness_CallInstance = CMock_Guts_MemNext(Mock.SaveBrightness_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveBrightness,CMockString_sourceInput);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceInput, sourceInput, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveBrightness,CMockString_pq_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pq_mode, pq_mode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveBrightness,CMockString_hdr_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hdr_type, hdr_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveBrightness,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveBrightness(CMOCK_SaveBrightness_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value);
void CMockExpectParameters_SaveBrightness(CMOCK_SaveBrightness_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value)
{
  cmock_call_instance->Expected_sourceInput = sourceInput;
  cmock_call_instance->Expected_pq_mode = pq_mode;
  cmock_call_instance->Expected_hdr_type = hdr_type;
  cmock_call_instance->Expected_value = value;
}

void SaveBrightness_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sourceInput, int pq_mode, int hdr_type, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveBrightness_CALL_INSTANCE));
  CMOCK_SaveBrightness_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveBrightness_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveBrightness_CallInstance = CMock_Guts_MemChain(Mock.SaveBrightness_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveBrightness(cmock_call_instance, sourceInput, pq_mode, hdr_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SaveHue(int sourceInput, int pq_mode, int hdr_type, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveHue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveHue);
  cmock_call_instance = (CMOCK_SaveHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveHue_CallInstance);
  Mock.SaveHue_CallInstance = CMock_Guts_MemNext(Mock.SaveHue_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveHue,CMockString_sourceInput);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceInput, sourceInput, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveHue,CMockString_pq_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pq_mode, pq_mode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveHue,CMockString_hdr_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hdr_type, hdr_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveHue,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveHue(CMOCK_SaveHue_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value);
void CMockExpectParameters_SaveHue(CMOCK_SaveHue_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value)
{
  cmock_call_instance->Expected_sourceInput = sourceInput;
  cmock_call_instance->Expected_pq_mode = pq_mode;
  cmock_call_instance->Expected_hdr_type = hdr_type;
  cmock_call_instance->Expected_value = value;
}

void SaveHue_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sourceInput, int pq_mode, int hdr_type, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveHue_CALL_INSTANCE));
  CMOCK_SaveHue_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveHue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveHue_CallInstance = CMock_Guts_MemChain(Mock.SaveHue_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveHue(cmock_call_instance, sourceInput, pq_mode, hdr_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SaveDynamicBacklight(int sourceInput, int pq_mode, int hdr_type, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveDynamicBacklight_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveDynamicBacklight);
  cmock_call_instance = (CMOCK_SaveDynamicBacklight_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveDynamicBacklight_CallInstance);
  Mock.SaveDynamicBacklight_CallInstance = CMock_Guts_MemNext(Mock.SaveDynamicBacklight_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveDynamicBacklight,CMockString_sourceInput);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceInput, sourceInput, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveDynamicBacklight,CMockString_pq_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pq_mode, pq_mode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveDynamicBacklight,CMockString_hdr_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hdr_type, hdr_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveDynamicBacklight,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveDynamicBacklight(CMOCK_SaveDynamicBacklight_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value);
void CMockExpectParameters_SaveDynamicBacklight(CMOCK_SaveDynamicBacklight_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value)
{
  cmock_call_instance->Expected_sourceInput = sourceInput;
  cmock_call_instance->Expected_pq_mode = pq_mode;
  cmock_call_instance->Expected_hdr_type = hdr_type;
  cmock_call_instance->Expected_value = value;
}

void SaveDynamicBacklight_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sourceInput, int pq_mode, int hdr_type, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveDynamicBacklight_CALL_INSTANCE));
  CMOCK_SaveDynamicBacklight_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveDynamicBacklight_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveDynamicBacklight_CallInstance = CMock_Guts_MemChain(Mock.SaveDynamicBacklight_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveDynamicBacklight(cmock_call_instance, sourceInput, pq_mode, hdr_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SaveDisplayMode(int sourceInput, int pq_mode, int hdr_type, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveDisplayMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveDisplayMode);
  cmock_call_instance = (CMOCK_SaveDisplayMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveDisplayMode_CallInstance);
  Mock.SaveDisplayMode_CallInstance = CMock_Guts_MemNext(Mock.SaveDisplayMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveDisplayMode,CMockString_sourceInput);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceInput, sourceInput, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveDisplayMode,CMockString_pq_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pq_mode, pq_mode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveDisplayMode,CMockString_hdr_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hdr_type, hdr_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveDisplayMode,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveDisplayMode(CMOCK_SaveDisplayMode_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value);
void CMockExpectParameters_SaveDisplayMode(CMOCK_SaveDisplayMode_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value)
{
  cmock_call_instance->Expected_sourceInput = sourceInput;
  cmock_call_instance->Expected_pq_mode = pq_mode;
  cmock_call_instance->Expected_hdr_type = hdr_type;
  cmock_call_instance->Expected_value = value;
}

void SaveDisplayMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sourceInput, int pq_mode, int hdr_type, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveDisplayMode_CALL_INSTANCE));
  CMOCK_SaveDisplayMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveDisplayMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveDisplayMode_CallInstance = CMock_Guts_MemChain(Mock.SaveDisplayMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveDisplayMode(cmock_call_instance, sourceInput, pq_mode, hdr_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SaveCMS(int sourceInput, int pq_mode, int hdr_type, int tunnel_type, int color_type, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveCMS_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveCMS);
  cmock_call_instance = (CMOCK_SaveCMS_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveCMS_CallInstance);
  Mock.SaveCMS_CallInstance = CMock_Guts_MemNext(Mock.SaveCMS_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveCMS,CMockString_sourceInput);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceInput, sourceInput, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveCMS,CMockString_pq_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pq_mode, pq_mode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveCMS,CMockString_hdr_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hdr_type, hdr_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveCMS,CMockString_tunnel_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_tunnel_type, tunnel_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveCMS,CMockString_color_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_color_type, color_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveCMS,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveCMS(CMOCK_SaveCMS_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int tunnel_type, int color_type, int value);
void CMockExpectParameters_SaveCMS(CMOCK_SaveCMS_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int tunnel_type, int color_type, int value)
{
  cmock_call_instance->Expected_sourceInput = sourceInput;
  cmock_call_instance->Expected_pq_mode = pq_mode;
  cmock_call_instance->Expected_hdr_type = hdr_type;
  cmock_call_instance->Expected_tunnel_type = tunnel_type;
  cmock_call_instance->Expected_color_type = color_type;
  cmock_call_instance->Expected_value = value;
}

void SaveCMS_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sourceInput, int pq_mode, int hdr_type, int tunnel_type, int color_type, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveCMS_CALL_INSTANCE));
  CMOCK_SaveCMS_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveCMS_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveCMS_CallInstance = CMock_Guts_MemChain(Mock.SaveCMS_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveCMS(cmock_call_instance, sourceInput, pq_mode, hdr_type, tunnel_type, color_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SaveDolbyMode(int sourceInput, int pq_mode, int hdr_type, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveDolbyMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveDolbyMode);
  cmock_call_instance = (CMOCK_SaveDolbyMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveDolbyMode_CallInstance);
  Mock.SaveDolbyMode_CallInstance = CMock_Guts_MemNext(Mock.SaveDolbyMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveDolbyMode,CMockString_sourceInput);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceInput, sourceInput, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveDolbyMode,CMockString_pq_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pq_mode, pq_mode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveDolbyMode,CMockString_hdr_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hdr_type, hdr_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveDolbyMode,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveDolbyMode(CMOCK_SaveDolbyMode_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value);
void CMockExpectParameters_SaveDolbyMode(CMOCK_SaveDolbyMode_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value)
{
  cmock_call_instance->Expected_sourceInput = sourceInput;
  cmock_call_instance->Expected_pq_mode = pq_mode;
  cmock_call_instance->Expected_hdr_type = hdr_type;
  cmock_call_instance->Expected_value = value;
}

void SaveDolbyMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sourceInput, int pq_mode, int hdr_type, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveDolbyMode_CALL_INSTANCE));
  CMOCK_SaveDolbyMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveDolbyMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveDolbyMode_CallInstance = CMock_Guts_MemChain(Mock.SaveDolbyMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveDolbyMode(cmock_call_instance, sourceInput, pq_mode, hdr_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

int GetNumberOfModesupported(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetNumberOfModesupported_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetNumberOfModesupported);
  cmock_call_instance = (CMOCK_GetNumberOfModesupported_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetNumberOfModesupported_CallInstance);
  Mock.GetNumberOfModesupported_CallInstance = CMock_Guts_MemNext(Mock.GetNumberOfModesupported_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void GetNumberOfModesupported_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetNumberOfModesupported_CALL_INSTANCE));
  CMOCK_GetNumberOfModesupported_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetNumberOfModesupported_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetNumberOfModesupported_CallInstance = CMock_Guts_MemChain(Mock.GetNumberOfModesupported_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int GetCurrentPQIndex(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetCurrentPQIndex_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetCurrentPQIndex);
  cmock_call_instance = (CMOCK_GetCurrentPQIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetCurrentPQIndex_CallInstance);
  Mock.GetCurrentPQIndex_CallInstance = CMock_Guts_MemNext(Mock.GetCurrentPQIndex_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void GetCurrentPQIndex_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetCurrentPQIndex_CALL_INSTANCE));
  CMOCK_GetCurrentPQIndex_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetCurrentPQIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetCurrentPQIndex_CallInstance = CMock_Guts_MemChain(Mock.GetCurrentPQIndex_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void GetAllSupportedPicModeIndex(int* pic_mode_index)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetAllSupportedPicModeIndex_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetAllSupportedPicModeIndex);
  cmock_call_instance = (CMOCK_GetAllSupportedPicModeIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetAllSupportedPicModeIndex_CallInstance);
  Mock.GetAllSupportedPicModeIndex_CallInstance = CMock_Guts_MemNext(Mock.GetAllSupportedPicModeIndex_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetAllSupportedPicModeIndex,CMockString_pic_mode_index);
    if (cmock_call_instance->Expected_pic_mode_index == NULL)
      { UNITY_TEST_ASSERT_NULL(pic_mode_index, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_pic_mode_index, pic_mode_index, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GetAllSupportedPicModeIndex(CMOCK_GetAllSupportedPicModeIndex_CALL_INSTANCE* cmock_call_instance, int* pic_mode_index);
void CMockExpectParameters_GetAllSupportedPicModeIndex(CMOCK_GetAllSupportedPicModeIndex_CALL_INSTANCE* cmock_call_instance, int* pic_mode_index)
{
  cmock_call_instance->Expected_pic_mode_index = pic_mode_index;
}

void GetAllSupportedPicModeIndex_CMockExpect(UNITY_LINE_TYPE cmock_line, int* pic_mode_index)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetAllSupportedPicModeIndex_CALL_INSTANCE));
  CMOCK_GetAllSupportedPicModeIndex_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetAllSupportedPicModeIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetAllSupportedPicModeIndex_CallInstance = CMock_Guts_MemChain(Mock.GetAllSupportedPicModeIndex_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetAllSupportedPicModeIndex(cmock_call_instance, pic_mode_index);
}

int GetCMSDefault(tvCMS_tunel_t color_tunel_type)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetCMSDefault_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetCMSDefault);
  cmock_call_instance = (CMOCK_GetCMSDefault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetCMSDefault_CallInstance);
  Mock.GetCMSDefault_CallInstance = CMock_Guts_MemNext(Mock.GetCMSDefault_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetCMSDefault,CMockString_color_tunel_type);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_color_tunel_type), (void*)(&color_tunel_type), sizeof(tvCMS_tunel_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetCMSDefault(CMOCK_GetCMSDefault_CALL_INSTANCE* cmock_call_instance, tvCMS_tunel_t color_tunel_type);
void CMockExpectParameters_GetCMSDefault(CMOCK_GetCMSDefault_CALL_INSTANCE* cmock_call_instance, tvCMS_tunel_t color_tunel_type)
{
  memcpy((void*)(&cmock_call_instance->Expected_color_tunel_type), (void*)(&color_tunel_type),
         sizeof(tvCMS_tunel_t[sizeof(color_tunel_type) == sizeof(tvCMS_tunel_t) ? 1 : -1])); /* add tvCMS_tunel_t to :treat_as_array if this causes an error */
}

void GetCMSDefault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvCMS_tunel_t color_tunel_type, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetCMSDefault_CALL_INSTANCE));
  CMOCK_GetCMSDefault_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetCMSDefault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetCMSDefault_CallInstance = CMock_Guts_MemChain(Mock.GetCMSDefault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetCMSDefault(cmock_call_instance, color_tunel_type);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int GetDolbyModeIndex(const char* dolbyMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetDolbyModeIndex_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetDolbyModeIndex);
  cmock_call_instance = (CMOCK_GetDolbyModeIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetDolbyModeIndex_CallInstance);
  Mock.GetDolbyModeIndex_CallInstance = CMock_Guts_MemNext(Mock.GetDolbyModeIndex_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetDolbyModeIndex,CMockString_dolbyMode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_dolbyMode, dolbyMode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetDolbyModeIndex(CMOCK_GetDolbyModeIndex_CALL_INSTANCE* cmock_call_instance, const char* dolbyMode);
void CMockExpectParameters_GetDolbyModeIndex(CMOCK_GetDolbyModeIndex_CALL_INSTANCE* cmock_call_instance, const char* dolbyMode)
{
  cmock_call_instance->Expected_dolbyMode = dolbyMode;
}

void GetDolbyModeIndex_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* dolbyMode, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetDolbyModeIndex_CALL_INSTANCE));
  CMOCK_GetDolbyModeIndex_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetDolbyModeIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetDolbyModeIndex_CallInstance = CMock_Guts_MemChain(Mock.GetDolbyModeIndex_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetDolbyModeIndex(cmock_call_instance, dolbyMode);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int ConvertVideoFormatToHDRFormat(tvVideoHDRFormat_t videoFormat)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ConvertVideoFormatToHDRFormat_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ConvertVideoFormatToHDRFormat);
  cmock_call_instance = (CMOCK_ConvertVideoFormatToHDRFormat_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ConvertVideoFormatToHDRFormat_CallInstance);
  Mock.ConvertVideoFormatToHDRFormat_CallInstance = CMock_Guts_MemNext(Mock.ConvertVideoFormatToHDRFormat_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ConvertVideoFormatToHDRFormat,CMockString_videoFormat);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_videoFormat), (void*)(&videoFormat), sizeof(tvVideoHDRFormat_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ConvertVideoFormatToHDRFormat(CMOCK_ConvertVideoFormatToHDRFormat_CALL_INSTANCE* cmock_call_instance, tvVideoHDRFormat_t videoFormat);
void CMockExpectParameters_ConvertVideoFormatToHDRFormat(CMOCK_ConvertVideoFormatToHDRFormat_CALL_INSTANCE* cmock_call_instance, tvVideoHDRFormat_t videoFormat)
{
  memcpy((void*)(&cmock_call_instance->Expected_videoFormat), (void*)(&videoFormat),
         sizeof(tvVideoHDRFormat_t[sizeof(videoFormat) == sizeof(tvVideoHDRFormat_t) ? 1 : -1])); /* add tvVideoHDRFormat_t to :treat_as_array if this causes an error */
}

void ConvertVideoFormatToHDRFormat_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvVideoHDRFormat_t videoFormat, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ConvertVideoFormatToHDRFormat_CALL_INSTANCE));
  CMOCK_ConvertVideoFormatToHDRFormat_CALL_INSTANCE* cmock_call_instance = (CMOCK_ConvertVideoFormatToHDRFormat_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ConvertVideoFormatToHDRFormat_CallInstance = CMock_Guts_MemChain(Mock.ConvertVideoFormatToHDRFormat_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ConvertVideoFormatToHDRFormat(cmock_call_instance, videoFormat);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int ConvertTVColorToVendorColor(tvDataComponentColor_t blComponentColor)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ConvertTVColorToVendorColor_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ConvertTVColorToVendorColor);
  cmock_call_instance = (CMOCK_ConvertTVColorToVendorColor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ConvertTVColorToVendorColor_CallInstance);
  Mock.ConvertTVColorToVendorColor_CallInstance = CMock_Guts_MemNext(Mock.ConvertTVColorToVendorColor_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ConvertTVColorToVendorColor,CMockString_blComponentColor);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_blComponentColor), (void*)(&blComponentColor), sizeof(tvDataComponentColor_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ConvertTVColorToVendorColor(CMOCK_ConvertTVColorToVendorColor_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blComponentColor);
void CMockExpectParameters_ConvertTVColorToVendorColor(CMOCK_ConvertTVColorToVendorColor_CALL_INSTANCE* cmock_call_instance, tvDataComponentColor_t blComponentColor)
{
  memcpy((void*)(&cmock_call_instance->Expected_blComponentColor), (void*)(&blComponentColor),
         sizeof(tvDataComponentColor_t[sizeof(blComponentColor) == sizeof(tvDataComponentColor_t) ? 1 : -1])); /* add tvDataComponentColor_t to :treat_as_array if this causes an error */
}

void ConvertTVColorToVendorColor_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvDataComponentColor_t blComponentColor, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ConvertTVColorToVendorColor_CALL_INSTANCE));
  CMOCK_ConvertTVColorToVendorColor_CALL_INSTANCE* cmock_call_instance = (CMOCK_ConvertTVColorToVendorColor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ConvertTVColorToVendorColor_CallInstance = CMock_Guts_MemChain(Mock.ConvertTVColorToVendorColor_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ConvertTVColorToVendorColor(cmock_call_instance, blComponentColor);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int ConvertHDRFormatToContentFormat(tvhdr_type_t hdrFormat)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ConvertHDRFormatToContentFormat_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ConvertHDRFormatToContentFormat);
  cmock_call_instance = (CMOCK_ConvertHDRFormatToContentFormat_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ConvertHDRFormatToContentFormat_CallInstance);
  Mock.ConvertHDRFormatToContentFormat_CallInstance = CMock_Guts_MemNext(Mock.ConvertHDRFormatToContentFormat_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ConvertHDRFormatToContentFormat,CMockString_hdrFormat);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hdrFormat), (void*)(&hdrFormat), sizeof(tvhdr_type_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ConvertHDRFormatToContentFormat(CMOCK_ConvertHDRFormatToContentFormat_CALL_INSTANCE* cmock_call_instance, tvhdr_type_t hdrFormat);
void CMockExpectParameters_ConvertHDRFormatToContentFormat(CMOCK_ConvertHDRFormatToContentFormat_CALL_INSTANCE* cmock_call_instance, tvhdr_type_t hdrFormat)
{
  memcpy((void*)(&cmock_call_instance->Expected_hdrFormat), (void*)(&hdrFormat),
         sizeof(tvhdr_type_t[sizeof(hdrFormat) == sizeof(tvhdr_type_t) ? 1 : -1])); /* add tvhdr_type_t to :treat_as_array if this causes an error */
}

void ConvertHDRFormatToContentFormat_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvhdr_type_t hdrFormat, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ConvertHDRFormatToContentFormat_CALL_INSTANCE));
  CMOCK_ConvertHDRFormatToContentFormat_CALL_INSTANCE* cmock_call_instance = (CMOCK_ConvertHDRFormatToContentFormat_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ConvertHDRFormatToContentFormat_CallInstance = CMock_Guts_MemChain(Mock.ConvertHDRFormatToContentFormat_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ConvertHDRFormatToContentFormat(cmock_call_instance, hdrFormat);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int GetCustomPQModeIndex(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetCustomPQModeIndex_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetCustomPQModeIndex);
  cmock_call_instance = (CMOCK_GetCustomPQModeIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetCustomPQModeIndex_CallInstance);
  Mock.GetCustomPQModeIndex_CallInstance = CMock_Guts_MemNext(Mock.GetCustomPQModeIndex_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void GetCustomPQModeIndex_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetCustomPQModeIndex_CALL_INSTANCE));
  CMOCK_GetCustomPQModeIndex_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetCustomPQModeIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetCustomPQModeIndex_CallInstance = CMock_Guts_MemChain(Mock.GetCustomPQModeIndex_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

tvError_t SetCMSState(tvCMS_tunel_t tunelType, tvcomponent_color_type_t colorType, tvcomponent_state_t componentState)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetCMSState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetCMSState);
  cmock_call_instance = (CMOCK_SetCMSState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetCMSState_CallInstance);
  Mock.SetCMSState_CallInstance = CMock_Guts_MemNext(Mock.SetCMSState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetCMSState,CMockString_tunelType);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_tunelType), (void*)(&tunelType), sizeof(tvCMS_tunel_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetCMSState,CMockString_colorType);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_colorType), (void*)(&colorType), sizeof(tvcomponent_color_type_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetCMSState,CMockString_componentState);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_componentState), (void*)(&componentState), sizeof(tvcomponent_state_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetCMSState(CMOCK_SetCMSState_CALL_INSTANCE* cmock_call_instance, tvCMS_tunel_t tunelType, tvcomponent_color_type_t colorType, tvcomponent_state_t componentState);
void CMockExpectParameters_SetCMSState(CMOCK_SetCMSState_CALL_INSTANCE* cmock_call_instance, tvCMS_tunel_t tunelType, tvcomponent_color_type_t colorType, tvcomponent_state_t componentState)
{
  memcpy((void*)(&cmock_call_instance->Expected_tunelType), (void*)(&tunelType),
         sizeof(tvCMS_tunel_t[sizeof(tunelType) == sizeof(tvCMS_tunel_t) ? 1 : -1])); /* add tvCMS_tunel_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_colorType), (void*)(&colorType),
         sizeof(tvcomponent_color_type_t[sizeof(colorType) == sizeof(tvcomponent_color_type_t) ? 1 : -1])); /* add tvcomponent_color_type_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_componentState), (void*)(&componentState),
         sizeof(tvcomponent_state_t[sizeof(componentState) == sizeof(tvcomponent_state_t) ? 1 : -1])); /* add tvcomponent_state_t to :treat_as_array if this causes an error */
}

void SetCMSState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvCMS_tunel_t tunelType, tvcomponent_color_type_t colorType, tvcomponent_state_t componentState, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetCMSState_CALL_INSTANCE));
  CMOCK_SetCMSState_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetCMSState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetCMSState_CallInstance = CMock_Guts_MemChain(Mock.SetCMSState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetCMSState(cmock_call_instance, tunelType, colorType, componentState);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

bool isWBUserDfault(tvDataColor_t wbvalue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_isWBUserDfault_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_isWBUserDfault);
  cmock_call_instance = (CMOCK_isWBUserDfault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.isWBUserDfault_CallInstance);
  Mock.isWBUserDfault_CallInstance = CMock_Guts_MemNext(Mock.isWBUserDfault_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_isWBUserDfault,CMockString_wbvalue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_wbvalue), (void*)(&wbvalue), sizeof(tvDataColor_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_isWBUserDfault(CMOCK_isWBUserDfault_CALL_INSTANCE* cmock_call_instance, tvDataColor_t wbvalue);
void CMockExpectParameters_isWBUserDfault(CMOCK_isWBUserDfault_CALL_INSTANCE* cmock_call_instance, tvDataColor_t wbvalue)
{
  memcpy((void*)(&cmock_call_instance->Expected_wbvalue), (void*)(&wbvalue),
         sizeof(tvDataColor_t[sizeof(wbvalue) == sizeof(tvDataColor_t) ? 1 : -1])); /* add tvDataColor_t to :treat_as_array if this causes an error */
}

void isWBUserDfault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvDataColor_t wbvalue, bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_isWBUserDfault_CALL_INSTANCE));
  CMOCK_isWBUserDfault_CALL_INSTANCE* cmock_call_instance = (CMOCK_isWBUserDfault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.isWBUserDfault_CallInstance = CMock_Guts_MemChain(Mock.isWBUserDfault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_isWBUserDfault(cmock_call_instance, wbvalue);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int GetWBRgbType(const char* color, const char* ctrl)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetWBRgbType_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetWBRgbType);
  cmock_call_instance = (CMOCK_GetWBRgbType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetWBRgbType_CallInstance);
  Mock.GetWBRgbType_CallInstance = CMock_Guts_MemNext(Mock.GetWBRgbType_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetWBRgbType,CMockString_color);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_color, color, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetWBRgbType,CMockString_ctrl);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_ctrl, ctrl, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetWBRgbType(CMOCK_GetWBRgbType_CALL_INSTANCE* cmock_call_instance, const char* color, const char* ctrl);
void CMockExpectParameters_GetWBRgbType(CMOCK_GetWBRgbType_CALL_INSTANCE* cmock_call_instance, const char* color, const char* ctrl)
{
  cmock_call_instance->Expected_color = color;
  cmock_call_instance->Expected_ctrl = ctrl;
}

void GetWBRgbType_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* color, const char* ctrl, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetWBRgbType_CALL_INSTANCE));
  CMOCK_GetWBRgbType_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetWBRgbType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetWBRgbType_CallInstance = CMock_Guts_MemChain(Mock.GetWBRgbType_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetWBRgbType(cmock_call_instance, color, ctrl);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

tvDataColor_t GetUSerWBValueOnInit(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetUSerWBValueOnInit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetUSerWBValueOnInit);
  cmock_call_instance = (CMOCK_GetUSerWBValueOnInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetUSerWBValueOnInit_CallInstance);
  Mock.GetUSerWBValueOnInit_CallInstance = CMock_Guts_MemNext(Mock.GetUSerWBValueOnInit_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void GetUSerWBValueOnInit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvDataColor_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetUSerWBValueOnInit_CALL_INSTANCE));
  CMOCK_GetUSerWBValueOnInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetUSerWBValueOnInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetUSerWBValueOnInit_CallInstance = CMock_Guts_MemChain(Mock.GetUSerWBValueOnInit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvDataColor_t[sizeof(cmock_to_return) == sizeof(tvDataColor_t) ? 1 : -1])); /* add tvDataColor_t to :treat_as_array if this causes an error */
}

bool areEqual(tvDataColor_t wbvalueThis, tvDataColor_t wbvalueThat)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_areEqual_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_areEqual);
  cmock_call_instance = (CMOCK_areEqual_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.areEqual_CallInstance);
  Mock.areEqual_CallInstance = CMock_Guts_MemNext(Mock.areEqual_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_areEqual,CMockString_wbvalueThis);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_wbvalueThis), (void*)(&wbvalueThis), sizeof(tvDataColor_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_areEqual,CMockString_wbvalueThat);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_wbvalueThat), (void*)(&wbvalueThat), sizeof(tvDataColor_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_areEqual(CMOCK_areEqual_CALL_INSTANCE* cmock_call_instance, tvDataColor_t wbvalueThis, tvDataColor_t wbvalueThat);
void CMockExpectParameters_areEqual(CMOCK_areEqual_CALL_INSTANCE* cmock_call_instance, tvDataColor_t wbvalueThis, tvDataColor_t wbvalueThat)
{
  memcpy((void*)(&cmock_call_instance->Expected_wbvalueThis), (void*)(&wbvalueThis),
         sizeof(tvDataColor_t[sizeof(wbvalueThis) == sizeof(tvDataColor_t) ? 1 : -1])); /* add tvDataColor_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_wbvalueThat), (void*)(&wbvalueThat),
         sizeof(tvDataColor_t[sizeof(wbvalueThat) == sizeof(tvDataColor_t) ? 1 : -1])); /* add tvDataColor_t to :treat_as_array if this causes an error */
}

void areEqual_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvDataColor_t wbvalueThis, tvDataColor_t wbvalueThat, bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_areEqual_CALL_INSTANCE));
  CMOCK_areEqual_CALL_INSTANCE* cmock_call_instance = (CMOCK_areEqual_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.areEqual_CallInstance = CMock_Guts_MemChain(Mock.areEqual_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_areEqual(cmock_call_instance, wbvalueThis, wbvalueThat);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

tvError_t SetColorTemperatureUser(int rgbType, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetColorTemperatureUser_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetColorTemperatureUser);
  cmock_call_instance = (CMOCK_SetColorTemperatureUser_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetColorTemperatureUser_CallInstance);
  Mock.SetColorTemperatureUser_CallInstance = CMock_Guts_MemNext(Mock.SetColorTemperatureUser_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemperatureUser,CMockString_rgbType);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_rgbType, rgbType, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetColorTemperatureUser,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetColorTemperatureUser(CMOCK_SetColorTemperatureUser_CALL_INSTANCE* cmock_call_instance, int rgbType, int value);
void CMockExpectParameters_SetColorTemperatureUser(CMOCK_SetColorTemperatureUser_CALL_INSTANCE* cmock_call_instance, int rgbType, int value)
{
  cmock_call_instance->Expected_rgbType = rgbType;
  cmock_call_instance->Expected_value = value;
}

void SetColorTemperatureUser_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int rgbType, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetColorTemperatureUser_CALL_INSTANCE));
  CMOCK_SetColorTemperatureUser_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetColorTemperatureUser_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetColorTemperatureUser_CallInstance = CMock_Guts_MemChain(Mock.SetColorTemperatureUser_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetColorTemperatureUser(cmock_call_instance, rgbType, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SaveColorTemperatureUser(int rgbType, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveColorTemperatureUser_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveColorTemperatureUser);
  cmock_call_instance = (CMOCK_SaveColorTemperatureUser_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveColorTemperatureUser_CallInstance);
  Mock.SaveColorTemperatureUser_CallInstance = CMock_Guts_MemNext(Mock.SaveColorTemperatureUser_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveColorTemperatureUser,CMockString_rgbType);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_rgbType, rgbType, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveColorTemperatureUser,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveColorTemperatureUser(CMOCK_SaveColorTemperatureUser_CALL_INSTANCE* cmock_call_instance, int rgbType, int value);
void CMockExpectParameters_SaveColorTemperatureUser(CMOCK_SaveColorTemperatureUser_CALL_INSTANCE* cmock_call_instance, int rgbType, int value)
{
  cmock_call_instance->Expected_rgbType = rgbType;
  cmock_call_instance->Expected_value = value;
}

void SaveColorTemperatureUser_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int rgbType, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveColorTemperatureUser_CALL_INSTANCE));
  CMOCK_SaveColorTemperatureUser_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveColorTemperatureUser_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveColorTemperatureUser_CallInstance = CMock_Guts_MemChain(Mock.SaveColorTemperatureUser_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveColorTemperatureUser(cmock_call_instance, rgbType, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetBacklightInfo(tvBacklightInfo_t backlightDefaults)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetBacklightInfo_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetBacklightInfo);
  cmock_call_instance = (CMOCK_SetBacklightInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetBacklightInfo_CallInstance);
  Mock.SetBacklightInfo_CallInstance = CMock_Guts_MemNext(Mock.SetBacklightInfo_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetBacklightInfo,CMockString_backlightDefaults);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_backlightDefaults), (void*)(&backlightDefaults), sizeof(tvBacklightInfo_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetBacklightInfo(CMOCK_SetBacklightInfo_CALL_INSTANCE* cmock_call_instance, tvBacklightInfo_t backlightDefaults);
void CMockExpectParameters_SetBacklightInfo(CMOCK_SetBacklightInfo_CALL_INSTANCE* cmock_call_instance, tvBacklightInfo_t backlightDefaults)
{
  memcpy((void*)(&cmock_call_instance->Expected_backlightDefaults), (void*)(&backlightDefaults),
         sizeof(tvBacklightInfo_t[sizeof(backlightDefaults) == sizeof(tvBacklightInfo_t) ? 1 : -1])); /* add tvBacklightInfo_t to :treat_as_array if this causes an error */
}

void SetBacklightInfo_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, tvBacklightInfo_t backlightDefaults, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetBacklightInfo_CALL_INSTANCE));
  CMOCK_SetBacklightInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetBacklightInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetBacklightInfo_CallInstance = CMock_Guts_MemChain(Mock.SetBacklightInfo_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetBacklightInfo(cmock_call_instance, backlightDefaults);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

int GetDriverEquivalentBLForCurrentFmt(int backlight)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetDriverEquivalentBLForCurrentFmt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetDriverEquivalentBLForCurrentFmt);
  cmock_call_instance = (CMOCK_GetDriverEquivalentBLForCurrentFmt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetDriverEquivalentBLForCurrentFmt_CallInstance);
  Mock.GetDriverEquivalentBLForCurrentFmt_CallInstance = CMock_Guts_MemNext(Mock.GetDriverEquivalentBLForCurrentFmt_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetDriverEquivalentBLForCurrentFmt,CMockString_backlight);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_backlight, backlight, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetDriverEquivalentBLForCurrentFmt(CMOCK_GetDriverEquivalentBLForCurrentFmt_CALL_INSTANCE* cmock_call_instance, int backlight);
void CMockExpectParameters_GetDriverEquivalentBLForCurrentFmt(CMOCK_GetDriverEquivalentBLForCurrentFmt_CALL_INSTANCE* cmock_call_instance, int backlight)
{
  cmock_call_instance->Expected_backlight = backlight;
}

void GetDriverEquivalentBLForCurrentFmt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int backlight, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetDriverEquivalentBLForCurrentFmt_CALL_INSTANCE));
  CMOCK_GetDriverEquivalentBLForCurrentFmt_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetDriverEquivalentBLForCurrentFmt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetDriverEquivalentBLForCurrentFmt_CallInstance = CMock_Guts_MemChain(Mock.GetDriverEquivalentBLForCurrentFmt_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetDriverEquivalentBLForCurrentFmt(cmock_call_instance, backlight);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int GetHLGModeIndex(const char* hlgMode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetHLGModeIndex_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetHLGModeIndex);
  cmock_call_instance = (CMOCK_GetHLGModeIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetHLGModeIndex_CallInstance);
  Mock.GetHLGModeIndex_CallInstance = CMock_Guts_MemNext(Mock.GetHLGModeIndex_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetHLGModeIndex,CMockString_hlgMode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_hlgMode, hlgMode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetHLGModeIndex(CMOCK_GetHLGModeIndex_CALL_INSTANCE* cmock_call_instance, const char* hlgMode);
void CMockExpectParameters_GetHLGModeIndex(CMOCK_GetHLGModeIndex_CALL_INSTANCE* cmock_call_instance, const char* hlgMode)
{
  cmock_call_instance->Expected_hlgMode = hlgMode;
}

void GetHLGModeIndex_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* hlgMode, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetHLGModeIndex_CALL_INSTANCE));
  CMOCK_GetHLGModeIndex_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetHLGModeIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetHLGModeIndex_CallInstance = CMock_Guts_MemChain(Mock.GetHLGModeIndex_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetHLGModeIndex(cmock_call_instance, hlgMode);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

int GetHDR10ModeIndex(const char* hdr10Mode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetHDR10ModeIndex_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetHDR10ModeIndex);
  cmock_call_instance = (CMOCK_GetHDR10ModeIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetHDR10ModeIndex_CallInstance);
  Mock.GetHDR10ModeIndex_CallInstance = CMock_Guts_MemNext(Mock.GetHDR10ModeIndex_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetHDR10ModeIndex,CMockString_hdr10Mode);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_hdr10Mode, hdr10Mode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetHDR10ModeIndex(CMOCK_GetHDR10ModeIndex_CALL_INSTANCE* cmock_call_instance, const char* hdr10Mode);
void CMockExpectParameters_GetHDR10ModeIndex(CMOCK_GetHDR10ModeIndex_CALL_INSTANCE* cmock_call_instance, const char* hdr10Mode)
{
  cmock_call_instance->Expected_hdr10Mode = hdr10Mode;
}

void GetHDR10ModeIndex_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* hdr10Mode, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetHDR10ModeIndex_CALL_INSTANCE));
  CMOCK_GetHDR10ModeIndex_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetHDR10ModeIndex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetHDR10ModeIndex_CallInstance = CMock_Guts_MemChain(Mock.GetHDR10ModeIndex_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetHDR10ModeIndex(cmock_call_instance, hdr10Mode);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

tvError_t SetBacklightFade(int from, int to, int duration)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetBacklightFade_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetBacklightFade);
  cmock_call_instance = (CMOCK_SetBacklightFade_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetBacklightFade_CallInstance);
  Mock.SetBacklightFade_CallInstance = CMock_Guts_MemNext(Mock.SetBacklightFade_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetBacklightFade,CMockString_from);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_from, from, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetBacklightFade,CMockString_to);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_to, to, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SetBacklightFade,CMockString_duration);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_duration, duration, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetBacklightFade(CMOCK_SetBacklightFade_CALL_INSTANCE* cmock_call_instance, int from, int to, int duration);
void CMockExpectParameters_SetBacklightFade(CMOCK_SetBacklightFade_CALL_INSTANCE* cmock_call_instance, int from, int to, int duration)
{
  cmock_call_instance->Expected_from = from;
  cmock_call_instance->Expected_to = to;
  cmock_call_instance->Expected_duration = duration;
}

void SetBacklightFade_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int from, int to, int duration, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetBacklightFade_CALL_INSTANCE));
  CMOCK_SetBacklightFade_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetBacklightFade_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetBacklightFade_CallInstance = CMock_Guts_MemChain(Mock.SetBacklightFade_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetBacklightFade(cmock_call_instance, from, to, duration);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t ReadAllModeConfigfile(const char* file, char* cpybuffer, const char* searchstring)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ReadAllModeConfigfile_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ReadAllModeConfigfile);
  cmock_call_instance = (CMOCK_ReadAllModeConfigfile_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ReadAllModeConfigfile_CallInstance);
  Mock.ReadAllModeConfigfile_CallInstance = CMock_Guts_MemNext(Mock.ReadAllModeConfigfile_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ReadAllModeConfigfile,CMockString_file);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_file, file, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ReadAllModeConfigfile,CMockString_cpybuffer);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_cpybuffer, cpybuffer, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ReadAllModeConfigfile,CMockString_searchstring);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_searchstring, searchstring, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ReadAllModeConfigfile(CMOCK_ReadAllModeConfigfile_CALL_INSTANCE* cmock_call_instance, const char* file, char* cpybuffer, const char* searchstring);
void CMockExpectParameters_ReadAllModeConfigfile(CMOCK_ReadAllModeConfigfile_CALL_INSTANCE* cmock_call_instance, const char* file, char* cpybuffer, const char* searchstring)
{
  cmock_call_instance->Expected_file = file;
  cmock_call_instance->Expected_cpybuffer = cpybuffer;
  cmock_call_instance->Expected_searchstring = searchstring;
}

void ReadAllModeConfigfile_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* file, char* cpybuffer, const char* searchstring, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ReadAllModeConfigfile_CALL_INSTANCE));
  CMOCK_ReadAllModeConfigfile_CALL_INSTANCE* cmock_call_instance = (CMOCK_ReadAllModeConfigfile_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ReadAllModeConfigfile_CallInstance = CMock_Guts_MemChain(Mock.ReadAllModeConfigfile_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ReadAllModeConfigfile(cmock_call_instance, file, cpybuffer, searchstring);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

void splitstringsfrombuffer(char* buffer, char* availableModes, unsigned short* totalcount)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_splitstringsfrombuffer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_splitstringsfrombuffer);
  cmock_call_instance = (CMOCK_splitstringsfrombuffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.splitstringsfrombuffer_CallInstance);
  Mock.splitstringsfrombuffer_CallInstance = CMock_Guts_MemNext(Mock.splitstringsfrombuffer_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_splitstringsfrombuffer,CMockString_buffer);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_buffer, buffer, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_splitstringsfrombuffer,CMockString_availableModes);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_availableModes, availableModes, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_splitstringsfrombuffer,CMockString_totalcount);
    if (cmock_call_instance->Expected_totalcount == NULL)
      { UNITY_TEST_ASSERT_NULL(totalcount, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_totalcount, totalcount, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_splitstringsfrombuffer(CMOCK_splitstringsfrombuffer_CALL_INSTANCE* cmock_call_instance, char* buffer, char* availableModes, unsigned short* totalcount);
void CMockExpectParameters_splitstringsfrombuffer(CMOCK_splitstringsfrombuffer_CALL_INSTANCE* cmock_call_instance, char* buffer, char* availableModes, unsigned short* totalcount)
{
  cmock_call_instance->Expected_buffer = buffer;
  cmock_call_instance->Expected_availableModes = availableModes;
  cmock_call_instance->Expected_totalcount = totalcount;
}

void splitstringsfrombuffer_CMockExpect(UNITY_LINE_TYPE cmock_line, char* buffer, char* availableModes, unsigned short* totalcount)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_splitstringsfrombuffer_CALL_INSTANCE));
  CMOCK_splitstringsfrombuffer_CALL_INSTANCE* cmock_call_instance = (CMOCK_splitstringsfrombuffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.splitstringsfrombuffer_CallInstance = CMock_Guts_MemChain(Mock.splitstringsfrombuffer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_splitstringsfrombuffer(cmock_call_instance, buffer, availableModes, totalcount);
}

void splitstringsandvaluefrombuffer(char* buffer, pic_modes_t** availableModes, unsigned short* totalcount)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_splitstringsandvaluefrombuffer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_splitstringsandvaluefrombuffer);
  cmock_call_instance = (CMOCK_splitstringsandvaluefrombuffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.splitstringsandvaluefrombuffer_CallInstance);
  Mock.splitstringsandvaluefrombuffer_CallInstance = CMock_Guts_MemNext(Mock.splitstringsandvaluefrombuffer_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_splitstringsandvaluefrombuffer,CMockString_buffer);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_buffer, buffer, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_splitstringsandvaluefrombuffer,CMockString_availableModes);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_availableModes, availableModes, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_splitstringsandvaluefrombuffer,CMockString_totalcount);
    if (cmock_call_instance->Expected_totalcount == NULL)
      { UNITY_TEST_ASSERT_NULL(totalcount, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_totalcount, totalcount, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_splitstringsandvaluefrombuffer(CMOCK_splitstringsandvaluefrombuffer_CALL_INSTANCE* cmock_call_instance, char* buffer, pic_modes_t** availableModes, unsigned short* totalcount);
void CMockExpectParameters_splitstringsandvaluefrombuffer(CMOCK_splitstringsandvaluefrombuffer_CALL_INSTANCE* cmock_call_instance, char* buffer, pic_modes_t** availableModes, unsigned short* totalcount)
{
  cmock_call_instance->Expected_buffer = buffer;
  cmock_call_instance->Expected_availableModes = availableModes;
  cmock_call_instance->Expected_totalcount = totalcount;
}

void splitstringsandvaluefrombuffer_CMockExpect(UNITY_LINE_TYPE cmock_line, char* buffer, pic_modes_t** availableModes, unsigned short* totalcount)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_splitstringsandvaluefrombuffer_CALL_INSTANCE));
  CMOCK_splitstringsandvaluefrombuffer_CALL_INSTANCE* cmock_call_instance = (CMOCK_splitstringsandvaluefrombuffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.splitstringsandvaluefrombuffer_CallInstance = CMock_Guts_MemChain(Mock.splitstringsandvaluefrombuffer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_splitstringsandvaluefrombuffer(cmock_call_instance, buffer, availableModes, totalcount);
}

tvError_t SetGammaMode(int mode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetGammaMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetGammaMode);
  cmock_call_instance = (CMOCK_SetGammaMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetGammaMode_CallInstance);
  Mock.SetGammaMode_CallInstance = CMock_Guts_MemNext(Mock.SetGammaMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetGammaMode,CMockString_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_mode, mode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetGammaMode(CMOCK_SetGammaMode_CALL_INSTANCE* cmock_call_instance, int mode);
void CMockExpectParameters_SetGammaMode(CMOCK_SetGammaMode_CALL_INSTANCE* cmock_call_instance, int mode)
{
  cmock_call_instance->Expected_mode = mode;
}

void SetGammaMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int mode, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetGammaMode_CALL_INSTANCE));
  CMOCK_SetGammaMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetGammaMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetGammaMode_CallInstance = CMock_Guts_MemChain(Mock.SetGammaMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetGammaMode(cmock_call_instance, mode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SetLocalDimmingLevel(int localDimmingLevel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SetLocalDimmingLevel_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SetLocalDimmingLevel);
  cmock_call_instance = (CMOCK_SetLocalDimmingLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SetLocalDimmingLevel_CallInstance);
  Mock.SetLocalDimmingLevel_CallInstance = CMock_Guts_MemNext(Mock.SetLocalDimmingLevel_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SetLocalDimmingLevel,CMockString_localDimmingLevel);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_localDimmingLevel, localDimmingLevel, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SetLocalDimmingLevel(CMOCK_SetLocalDimmingLevel_CALL_INSTANCE* cmock_call_instance, int localDimmingLevel);
void CMockExpectParameters_SetLocalDimmingLevel(CMOCK_SetLocalDimmingLevel_CALL_INSTANCE* cmock_call_instance, int localDimmingLevel)
{
  cmock_call_instance->Expected_localDimmingLevel = localDimmingLevel;
}

void SetLocalDimmingLevel_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int localDimmingLevel, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SetLocalDimmingLevel_CALL_INSTANCE));
  CMOCK_SetLocalDimmingLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_SetLocalDimmingLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SetLocalDimmingLevel_CallInstance = CMock_Guts_MemChain(Mock.SetLocalDimmingLevel_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SetLocalDimmingLevel(cmock_call_instance, localDimmingLevel);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t GetLocalDimmingLevel(int* localDimmingLevel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetLocalDimmingLevel_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetLocalDimmingLevel);
  cmock_call_instance = (CMOCK_GetLocalDimmingLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetLocalDimmingLevel_CallInstance);
  Mock.GetLocalDimmingLevel_CallInstance = CMock_Guts_MemNext(Mock.GetLocalDimmingLevel_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetLocalDimmingLevel,CMockString_localDimmingLevel);
    if (cmock_call_instance->Expected_localDimmingLevel == NULL)
      { UNITY_TEST_ASSERT_NULL(localDimmingLevel, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_localDimmingLevel, localDimmingLevel, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GetLocalDimmingLevel(CMOCK_GetLocalDimmingLevel_CALL_INSTANCE* cmock_call_instance, int* localDimmingLevel);
void CMockExpectParameters_GetLocalDimmingLevel(CMOCK_GetLocalDimmingLevel_CALL_INSTANCE* cmock_call_instance, int* localDimmingLevel)
{
  cmock_call_instance->Expected_localDimmingLevel = localDimmingLevel;
}

void GetLocalDimmingLevel_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int* localDimmingLevel, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetLocalDimmingLevel_CALL_INSTANCE));
  CMOCK_GetLocalDimmingLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetLocalDimmingLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetLocalDimmingLevel_CallInstance = CMock_Guts_MemChain(Mock.GetLocalDimmingLevel_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetLocalDimmingLevel(cmock_call_instance, localDimmingLevel);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

tvError_t SaveLocalDimmingLevel(int sourceInput, int pq_mode, int hdr_type, int value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SaveLocalDimmingLevel_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SaveLocalDimmingLevel);
  cmock_call_instance = (CMOCK_SaveLocalDimmingLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SaveLocalDimmingLevel_CallInstance);
  Mock.SaveLocalDimmingLevel_CallInstance = CMock_Guts_MemNext(Mock.SaveLocalDimmingLevel_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SaveLocalDimmingLevel,CMockString_sourceInput);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_sourceInput, sourceInput, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveLocalDimmingLevel,CMockString_pq_mode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pq_mode, pq_mode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveLocalDimmingLevel,CMockString_hdr_type);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_hdr_type, hdr_type, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_SaveLocalDimmingLevel,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_SaveLocalDimmingLevel(CMOCK_SaveLocalDimmingLevel_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value);
void CMockExpectParameters_SaveLocalDimmingLevel(CMOCK_SaveLocalDimmingLevel_CALL_INSTANCE* cmock_call_instance, int sourceInput, int pq_mode, int hdr_type, int value)
{
  cmock_call_instance->Expected_sourceInput = sourceInput;
  cmock_call_instance->Expected_pq_mode = pq_mode;
  cmock_call_instance->Expected_hdr_type = hdr_type;
  cmock_call_instance->Expected_value = value;
}

void SaveLocalDimmingLevel_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int sourceInput, int pq_mode, int hdr_type, int value, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SaveLocalDimmingLevel_CALL_INSTANCE));
  CMOCK_SaveLocalDimmingLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_SaveLocalDimmingLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SaveLocalDimmingLevel_CallInstance = CMock_Guts_MemChain(Mock.SaveLocalDimmingLevel_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SaveLocalDimmingLevel(cmock_call_instance, sourceInput, pq_mode, hdr_type, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

void SwitchEDID(int pqmode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SwitchEDID_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_SwitchEDID);
  cmock_call_instance = (CMOCK_SwitchEDID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SwitchEDID_CallInstance);
  Mock.SwitchEDID_CallInstance = CMock_Guts_MemNext(Mock.SwitchEDID_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_SwitchEDID,CMockString_pqmode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_pqmode, pqmode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_SwitchEDID(CMOCK_SwitchEDID_CALL_INSTANCE* cmock_call_instance, int pqmode);
void CMockExpectParameters_SwitchEDID(CMOCK_SwitchEDID_CALL_INSTANCE* cmock_call_instance, int pqmode)
{
  cmock_call_instance->Expected_pqmode = pqmode;
}

void SwitchEDID_CMockExpect(UNITY_LINE_TYPE cmock_line, int pqmode)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SwitchEDID_CALL_INSTANCE));
  CMOCK_SwitchEDID_CALL_INSTANCE* cmock_call_instance = (CMOCK_SwitchEDID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SwitchEDID_CallInstance = CMock_Guts_MemChain(Mock.SwitchEDID_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_SwitchEDID(cmock_call_instance, pqmode);
}

tvError_t UpdateEDIDAndSetDimmingLevel(int dimmingLevel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_UpdateEDIDAndSetDimmingLevel_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_UpdateEDIDAndSetDimmingLevel);
  cmock_call_instance = (CMOCK_UpdateEDIDAndSetDimmingLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.UpdateEDIDAndSetDimmingLevel_CallInstance);
  Mock.UpdateEDIDAndSetDimmingLevel_CallInstance = CMock_Guts_MemNext(Mock.UpdateEDIDAndSetDimmingLevel_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_UpdateEDIDAndSetDimmingLevel,CMockString_dimmingLevel);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_dimmingLevel, dimmingLevel, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_UpdateEDIDAndSetDimmingLevel(CMOCK_UpdateEDIDAndSetDimmingLevel_CALL_INSTANCE* cmock_call_instance, int dimmingLevel);
void CMockExpectParameters_UpdateEDIDAndSetDimmingLevel(CMOCK_UpdateEDIDAndSetDimmingLevel_CALL_INSTANCE* cmock_call_instance, int dimmingLevel)
{
  cmock_call_instance->Expected_dimmingLevel = dimmingLevel;
}

void UpdateEDIDAndSetDimmingLevel_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int dimmingLevel, tvError_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_UpdateEDIDAndSetDimmingLevel_CALL_INSTANCE));
  CMOCK_UpdateEDIDAndSetDimmingLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_UpdateEDIDAndSetDimmingLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.UpdateEDIDAndSetDimmingLevel_CallInstance = CMock_Guts_MemChain(Mock.UpdateEDIDAndSetDimmingLevel_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_UpdateEDIDAndSetDimmingLevel(cmock_call_instance, dimmingLevel);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(tvError_t[sizeof(cmock_to_return) == sizeof(tvError_t) ? 1 : -1])); /* add tvError_t to :treat_as_array if this causes an error */
}

void GetLDIMAndEDIDLevel(int dimmingMode, int format, int* dimmingLevel, int* edidLevel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GetLDIMAndEDIDLevel_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GetLDIMAndEDIDLevel);
  cmock_call_instance = (CMOCK_GetLDIMAndEDIDLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GetLDIMAndEDIDLevel_CallInstance);
  Mock.GetLDIMAndEDIDLevel_CallInstance = CMock_Guts_MemNext(Mock.GetLDIMAndEDIDLevel_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_GetLDIMAndEDIDLevel,CMockString_dimmingMode);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_dimmingMode, dimmingMode, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetLDIMAndEDIDLevel,CMockString_format);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_format, format, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GetLDIMAndEDIDLevel,CMockString_dimmingLevel);
    if (cmock_call_instance->Expected_dimmingLevel == NULL)
      { UNITY_TEST_ASSERT_NULL(dimmingLevel, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_dimmingLevel, dimmingLevel, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_GetLDIMAndEDIDLevel,CMockString_edidLevel);
    if (cmock_call_instance->Expected_edidLevel == NULL)
      { UNITY_TEST_ASSERT_NULL(edidLevel, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_edidLevel, edidLevel, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GetLDIMAndEDIDLevel(CMOCK_GetLDIMAndEDIDLevel_CALL_INSTANCE* cmock_call_instance, int dimmingMode, int format, int* dimmingLevel, int* edidLevel);
void CMockExpectParameters_GetLDIMAndEDIDLevel(CMOCK_GetLDIMAndEDIDLevel_CALL_INSTANCE* cmock_call_instance, int dimmingMode, int format, int* dimmingLevel, int* edidLevel)
{
  cmock_call_instance->Expected_dimmingMode = dimmingMode;
  cmock_call_instance->Expected_format = format;
  cmock_call_instance->Expected_dimmingLevel = dimmingLevel;
  cmock_call_instance->Expected_edidLevel = edidLevel;
}

void GetLDIMAndEDIDLevel_CMockExpect(UNITY_LINE_TYPE cmock_line, int dimmingMode, int format, int* dimmingLevel, int* edidLevel)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GetLDIMAndEDIDLevel_CALL_INSTANCE));
  CMOCK_GetLDIMAndEDIDLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_GetLDIMAndEDIDLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GetLDIMAndEDIDLevel_CallInstance = CMock_Guts_MemChain(Mock.GetLDIMAndEDIDLevel_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_GetLDIMAndEDIDLevel(cmock_call_instance, dimmingMode, format, dimmingLevel, edidLevel);
}

